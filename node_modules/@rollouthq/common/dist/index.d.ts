import * as _tiptap_core from '@tiptap/core';
import { Editor, Extension, NodeConfig, Node, JSONContent, TextSerializer } from '@tiptap/core';
import * as zod from 'zod';
import { ZodType, z as z$1, ZodTypeAny } from 'zod';
import * as _tiptap_extension_link from '@tiptap/extension-link';
import * as _tiptap_extension_bold from '@tiptap/extension-bold';
import * as _tiptap_extension_blockquote from '@tiptap/extension-blockquote';
import * as prosemirror_model from 'prosemirror-model';
import { Schema } from 'prosemirror-model';

declare type EnterHandlerOptions = {
    handler: (props: {
        editor: Editor;
    }) => boolean | undefined;
};
declare const EnterHandler: Extension<EnterHandlerOptions, any>;

declare type EscHandlerOptions = {
    handler: (props: {
        editor: Editor;
    }) => boolean | undefined;
};
declare const EscHandler: Extension<EscHandlerOptions, any>;

declare const Link: _tiptap_core.Mark<_tiptap_extension_link.LinkOptions, any>;

declare const MENTION_SYMBOL = "@";
declare type Variable = {
    id: string;
    label: string;
    type: "string" | "number" | "boolean" | "email";
};
declare module "@tiptap/core" {
    interface Commands<ReturnType> {
        mention: {
            insertMentionSymbol: () => ReturnType;
        };
    }
}
interface MentionStorage {
    variables: readonly Variable[] | null;
    setVariables(newVariables: readonly Variable[] | null): void;
    menuContainer: HTMLDivElement | null;
}
declare type MentionOptions = {
    variables: readonly Variable[] | null;
};
declare const mentionConfig: Partial<NodeConfig<MentionOptions, MentionStorage>>;
declare const Mention: Node<MentionOptions, MentionStorage>;

declare function getSuggestions(editor: Editor, query: string): Variable[];

declare const CURLY_BRACKETS_SYMBOL = "{{";
declare type CurlyBracketsVariable = {
    id: string;
    label: string;
    type: "string" | "number" | "boolean" | "email";
};
declare module "@tiptap/core" {
    interface Commands<ReturnType> {
        curlyBrackets: {
            insertCurlyBracketsSymbol: () => ReturnType;
        };
    }
}
interface CurlyBracketsStorage {
    variables: readonly CurlyBracketsVariable[] | null;
    setVariables(newVariables: readonly CurlyBracketsVariable[] | null): void;
    menuContainer: HTMLDivElement | null;
}
declare type CurlyBracketsOptions = {
    variables: readonly CurlyBracketsVariable[] | null;
};
declare const curlyBracketsConfig: Partial<NodeConfig<CurlyBracketsOptions, CurlyBracketsStorage>>;
declare const CurlyBrackets: Node<CurlyBracketsOptions, CurlyBracketsStorage>;

declare function getCurlyBracketsSuggestions(editor: Editor, query: string): CurlyBracketsVariable[];

declare type ShiftEnterHandlerOptions = {
    handler: (props: {
        editor: Editor;
    }) => boolean | undefined;
};
declare const ShiftEnterHandler: Extension<ShiftEnterHandlerOptions, any>;

declare const FORMATTING_EXTENSIONS: (_tiptap_core.Node<_tiptap_extension_blockquote.BlockquoteOptions, any> | _tiptap_core.Mark<_tiptap_extension_bold.BoldOptions, any> | _tiptap_core.Extension<any, any>)[];

declare const AnyBlockDocument: Node<any, any>;

declare const SingleParagraphDocument: Node<any, any>;

declare const SCHEMA_EXTENSIONS: (_tiptap_core.Mark<_tiptap_extension_bold.BoldOptions, any> | _tiptap_core.Extension<any, any> | _tiptap_core.Node<any, any>)[];
declare const schema: prosemirror_model.Schema<any, any>;

declare function appendText(original: JSONContent, stringToAppend: string): JSONContent;

declare function flatMapMentions(contentUnresolved: JSONContent, cb: (node: JSONContent) => JSONContent[]): JSONContent;

declare function createDocument(content: JSONContent[]): RichEditorContent;
declare function createMention(variableId: string): {
    type: string;
    attrs: {
        variable: {
            id: string;
        };
    };
};
declare function createParagraph(content: JSONContent[]): {
    type: string;
    content: JSONContent[];
};
declare function createDocumentWithMention(variableId: string): RichEditorContent;
declare function plainToRichText(plainText: string): RichEditorContent;
declare function toTextNode(plainText: string): JSONContent;

declare function prependText(original: JSONContent, stringToAppend: string): JSONContent;

declare function resolveMentions(contentResolved: JSONContent, variables: readonly Variable[]): JSONContent | null;

declare function richTextToPlain(contentResolved: JSONContent, fallbackEmptyToLabel?: boolean): string;
declare function getTextSeralizersFromSchema(s: Schema): Record<string, TextSerializer>;

declare function toHTML(resolvedContent: JSONContent): string;

declare function unresolveMentions(contentResolved: JSONContent): JSONContent | null;

declare function curlyTemplate(template: string): RichEditorContent;

declare type RichEditorContent = Omit<JSONContent, "doc"> & {
    type: "doc";
    content: JSONContent[];
};

declare function capitalize<T extends string>(text: T): Capitalize<T>;

declare const ROLLOUTHQ_VARIABLE_PREFIX = "ROLLOUTHQ_VARIABLE_";
declare function isVariable(id: string | undefined): boolean;

declare function zodGuard<T extends ZodType>(zodType: T): (x: unknown) => x is z$1.TypeOf<T>;
declare function passesValidation<T extends ZodType>(zodType: T, x: unknown): x is z$1.infer<T>;

declare const zRichEditorContent: z$1.ZodEffects<z$1.ZodEffects<z$1.ZodObject<{}, "passthrough", z$1.ZodTypeAny, {}, {}>, {}, {}>, RichEditorContent, {}>;
declare function isZRichEditorContent<T extends ZodTypeAny>(type: T): boolean;

declare type InputDef = {
    key: string;
    label: string;
    type: "string" | "plainText" | "dropdown";
};
declare function inputDefToZodObject(inputs: InputDef[]): z$1.ZodObject<any, "strip", z$1.ZodTypeAny, {
    [x: string]: any;
}, {
    [x: string]: any;
}>;

declare const z: {
    literal: <T extends zod.Primitive>(value: T, params?: {
        errorMap?: ((issue: zod.ZodIssueOptionalMessage, _ctx: {
            defaultError: string;
            data: any;
        }) => {
            message: string;
        }) | undefined;
        invalid_type_error?: string | undefined;
        required_error?: string | undefined;
        description?: string | undefined;
    } | undefined) => zod.ZodLiteral<T>;
    boolean: (params?: {
        errorMap?: ((issue: zod.ZodIssueOptionalMessage, _ctx: {
            defaultError: string;
            data: any;
        }) => {
            message: string;
        }) | undefined;
        invalid_type_error?: string | undefined;
        required_error?: string | undefined;
        description?: string | undefined;
    } | undefined) => zod.ZodBoolean;
    object: <T_1 extends zod.ZodRawShape>(shape: T_1, params?: {
        errorMap?: ((issue: zod.ZodIssueOptionalMessage, _ctx: {
            defaultError: string;
            data: any;
        }) => {
            message: string;
        }) | undefined;
        invalid_type_error?: string | undefined;
        required_error?: string | undefined;
        description?: string | undefined;
    } | undefined) => zod.ZodObject<T_1, "strip", ZodTypeAny, zod.objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2]["_output"]; }> extends infer T_2 ? { [k_1 in keyof T_2]: zod.objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k]["_output"]; }>[k_1]; } : never, zod.objectUtil.addQuestionMarks<{ [k_2_1 in keyof T_1]: T_1[k_2_1]["_input"]; }> extends infer T_3 ? { [k_3 in keyof T_3]: zod.objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2]["_input"]; }>[k_3]; } : never>;
    record: typeof zod.ZodRecord.create;
    string: (params?: {
        errorMap?: ((issue: zod.ZodIssueOptionalMessage, _ctx: {
            defaultError: string;
            data: any;
        }) => {
            message: string;
        }) | undefined;
        invalid_type_error?: string | undefined;
        required_error?: string | undefined;
        description?: string | undefined;
    } | undefined) => zod.ZodString;
    richEditorContent: zod.ZodEffects<zod.ZodEffects<zod.ZodObject<{}, "passthrough", ZodTypeAny, {}, {}>, {}, {}>, RichEditorContent, {}>;
    union: <T_4 extends readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(types: T_4, params?: {
        errorMap?: ((issue: zod.ZodIssueOptionalMessage, _ctx: {
            defaultError: string;
            data: any;
        }) => {
            message: string;
        }) | undefined;
        invalid_type_error?: string | undefined;
        required_error?: string | undefined;
        description?: string | undefined;
    } | undefined) => zod.ZodUnion<T_4>;
};
declare function unwrapOptional(type: ZodTypeAny): ZodTypeAny;

export { AnyBlockDocument, CURLY_BRACKETS_SYMBOL, CurlyBrackets, CurlyBracketsOptions, CurlyBracketsStorage, CurlyBracketsVariable, EnterHandler, EnterHandlerOptions, EscHandler, EscHandlerOptions, FORMATTING_EXTENSIONS, InputDef, Link, MENTION_SYMBOL, Mention, MentionOptions, MentionStorage, ROLLOUTHQ_VARIABLE_PREFIX, RichEditorContent, SCHEMA_EXTENSIONS, ShiftEnterHandler, ShiftEnterHandlerOptions, SingleParagraphDocument, Variable, appendText, capitalize, createDocument, createDocumentWithMention, createMention, createParagraph, curlyBracketsConfig, curlyTemplate, flatMapMentions, getCurlyBracketsSuggestions, getSuggestions, getTextSeralizersFromSchema, inputDefToZodObject, isVariable, isZRichEditorContent, mentionConfig, passesValidation, plainToRichText, prependText, resolveMentions, richTextToPlain, schema, toHTML, toTextNode, unresolveMentions, unwrapOptional, z, zRichEditorContent, zodGuard };
