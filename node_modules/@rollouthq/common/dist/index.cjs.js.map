{"version":3,"sources":["../src/index.ts","../src/rich-editor/extensions/enter-handler/enter-handler.extension.ts","../src/rich-editor/extensions/esc-handler/esc-handler.extension.ts","../src/rich-editor/extensions/link/link.extension.ts","../src/rich-editor/extensions/mention/mention.extension.ts","../src/rich-editor/extensions/mention/get-suggestions.ts","../src/rich-editor/extensions/curly-brackets/curly-brackets.extension.ts","../src/rich-editor/extensions/curly-brackets/get-suggestions.ts","../src/rich-editor/extensions/shift-enter-handler/shift-enter-handler.extension.ts","../src/rich-editor/formatting.ts","../src/rich-editor/nodes/document/any-block-document.ts","../src/rich-editor/nodes/document/single-paragraph-document.ts","../src/rich-editor/schema.ts","../../../node_modules/orderedmap/index.es.js","../../../node_modules/prosemirror-model/src/diff.js","../../../node_modules/prosemirror-model/src/fragment.js","../../../node_modules/prosemirror-model/src/comparedeep.js","../../../node_modules/prosemirror-model/src/mark.js","../../../node_modules/prosemirror-model/src/replace.js","../../../node_modules/prosemirror-model/src/resolvedpos.js","../../../node_modules/prosemirror-model/src/node.js","../../../node_modules/prosemirror-model/src/content.js","../../../node_modules/prosemirror-model/src/schema.js","../../../node_modules/prosemirror-model/src/from_dom.js","../../../node_modules/prosemirror-model/src/to_dom.js","../../../node_modules/prosemirror-transform/src/map.js","../../../node_modules/prosemirror-transform/src/transform.js","../../../node_modules/prosemirror-transform/src/step.js","../../../node_modules/prosemirror-transform/src/replace_step.js","../../../node_modules/prosemirror-transform/src/structure.js","../../../node_modules/prosemirror-transform/src/mark_step.js","../../../node_modules/prosemirror-transform/src/mark.js","../../../node_modules/prosemirror-transform/src/replace.js","../src/rich-editor/utils/plainToRichText.ts","../src/rich-editor/utils/appendText.ts","../src/rich-editor/utils/mapMentions.ts","../src/rich-editor/utils/prependText.ts","../src/rich-editor/utils/resolveMentions.ts","../src/rich-editor/utils/richTextToPlain.ts","../src/rich-editor/utils/toHTML.ts","../src/rich-editor/utils/unresolveMentions.ts","../src/rich-editor/utils/curly-template.ts","../src/utils/capitalize.ts","../src/utils/is-variable.ts","../src/utils/zod-guard.ts","../src/schema/index.ts","../src/schema/zod-rich-editor-content.ts","../src/schema/input-def-to-zod-object.ts"],"sourcesContent":["export * from \"./rich-editor\";\nexport * from \"./utils\";\nexport * from \"./schema\";\n","import { Editor, Extension } from \"@tiptap/core\";\n\nexport type EnterHandlerOptions = {\n  handler: (props: { editor: Editor }) => boolean | undefined;\n};\n\nexport const EnterHandler = Extension.create<EnterHandlerOptions>({\n  name: \"EnterHandler\",\n  addKeyboardShortcuts() {\n    return {\n      Enter: (props) => {\n        return this.options.handler(props) ?? false;\n      },\n    };\n  },\n});\n","import { Editor, Extension } from \"@tiptap/core\";\n\nexport type EscHandlerOptions = {\n  handler: (props: { editor: Editor }) => boolean | undefined;\n};\n\nexport const EscHandler = Extension.create<EscHandlerOptions>({\n  name: \"EscHandler\",\n  addKeyboardShortcuts() {\n    return {\n      Escape: (props) => {\n        return this.options.handler(props) ?? false;\n      },\n    };\n  },\n});\n","import TiptapLink from \"@tiptap/extension-link\";\n\nexport const Link = TiptapLink.extend({\n  addOptions() {\n    return {\n      ...TiptapLink.options,\n      openOnClick: false,\n    };\n  },\n});\n","import { Node, mergeAttributes, NodeConfig } from \"@tiptap/core\";\n\nexport const MENTION_SYMBOL = \"@\";\n\nexport type Variable = {\n  id: string;\n  label: string;\n  type: \"string\" | \"number\" | \"boolean\" | \"email\";\n};\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    mention: {\n      insertMentionSymbol: () => ReturnType;\n    };\n  }\n}\n\nexport interface MentionStorage {\n  variables: readonly Variable[] | null;\n  setVariables(newVariables: readonly Variable[] | null): void;\n  menuContainer: HTMLDivElement | null;\n}\n\nexport type MentionOptions = {\n  variables: readonly Variable[] | null;\n};\n\nexport const mentionConfig: Partial<\n  NodeConfig<MentionOptions, MentionStorage>\n> = {\n  name: \"mention\",\n  // Increase the priority in order to load this before the EnterHandler extension.\n  // We want to let the Mention extension handle the enter keypress first.\n  priority: 110,\n  group: \"inline\",\n  inline: true,\n  selectable: false,\n  atom: true,\n\n  addCommands() {\n    return {\n      insertMentionSymbol: () => {\n        return ({ chain }) =>\n          chain().insertContent(MENTION_SYMBOL).focus().run();\n      },\n    };\n  },\n\n  addStorage() {\n    return {\n      variables: this.options?.variables ?? null,\n      setVariables(newVariables: Variable[]) {\n        this.variables = newVariables;\n      },\n      menuContainer: null,\n    };\n  },\n\n  addAttributes() {\n    return {\n      variable: {\n        default: null,\n        parseHTML: (element) => {\n          return {\n            id: element.getAttribute(\"data-variable-id\"),\n            label: element.getAttribute(\"data-variable-label\"),\n            type: element.getAttribute(\"data-variable-type\"),\n          };\n        },\n        renderHTML: (attributes) => {\n          if (!attributes.variable) {\n            return {};\n          }\n\n          return {\n            \"data-variable-id\": attributes.variable.id,\n            \"data-variable-label\": attributes.variable.label,\n            \"data-variable-type\": attributes.variable.type,\n          };\n        },\n      },\n    };\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `span[data-type=\"${this.name}\"]`,\n      },\n    ];\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      \"span\",\n      mergeAttributes({ \"data-type\": this.name }, HTMLAttributes),\n      `${node.attrs.variable?.label}`,\n    ];\n  },\n\n  renderText({ node }) {\n    const variable = node.attrs.variable as Variable;\n    return `${variable.label ?? variable.id}`;\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Backspace: () =>\n        this.editor.commands.command(({ tr, state }) => {\n          let isMention = false;\n          const { selection } = state;\n          const { empty, anchor } = selection;\n\n          if (!empty) {\n            return false;\n          }\n\n          state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {\n            if (node.type.name === this.name) {\n              isMention = true;\n              tr.insertText(MENTION_SYMBOL, pos, pos + node.nodeSize);\n\n              return false;\n            }\n          });\n\n          return isMention;\n        }),\n    };\n  },\n};\n\nexport const Mention = Node.create<MentionOptions, MentionStorage>(\n  mentionConfig\n);\n","import { Editor } from \"@tiptap/core\";\nimport { matchSorter } from \"match-sorter\";\n\nimport { Variable, MentionStorage } from \"./mention.extension\";\n\nfunction match(variables: readonly Variable[], query: string) {\n  return matchSorter(variables, query, {\n    keys: [(option) => option.label],\n    threshold: matchSorter.rankings.ACRONYM,\n  });\n}\n\nexport function getSuggestions(editor: Editor, query: string): Variable[] {\n  const mentionStorage = editor.storage.mention as MentionStorage;\n  const { variables } = mentionStorage;\n\n  if (!variables) {\n    return [];\n  }\n\n  return match(variables, query);\n}\n","import { Node, mergeAttributes, NodeConfig } from \"@tiptap/core\";\n\nexport const CURLY_BRACKETS_SYMBOL = \"{{\";\n\nexport type CurlyBracketsVariable = {\n  id: string;\n  label: string;\n  type: \"string\" | \"number\" | \"boolean\" | \"email\";\n};\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    curlyBrackets: {\n      insertCurlyBracketsSymbol: () => ReturnType;\n    };\n  }\n}\n\nexport interface CurlyBracketsStorage {\n  variables: readonly CurlyBracketsVariable[] | null;\n  setVariables(newVariables: readonly CurlyBracketsVariable[] | null): void;\n  menuContainer: HTMLDivElement | null;\n}\n\nexport type CurlyBracketsOptions = {\n  variables: readonly CurlyBracketsVariable[] | null;\n};\n\nexport const curlyBracketsConfig: Partial<\n  NodeConfig<CurlyBracketsOptions, CurlyBracketsStorage>\n> = {\n  name: \"curly-brackets\",\n  // Increase the priority in order to load this before the EnterHandler extension.\n  // We want to let the Curly Brackets extension handle the enter keypress first.\n  priority: 110,\n  group: \"inline\",\n  inline: true,\n  selectable: false,\n  atom: true,\n\n  addCommands() {\n    return {\n      insertCurlyBracketsSymbol: () => {\n        return ({ chain }) =>\n          chain().insertContent(CURLY_BRACKETS_SYMBOL).focus().run();\n      },\n    };\n  },\n\n  addStorage() {\n    return {\n      variables: this.options?.variables ?? null,\n      setVariables(newVariables: CurlyBracketsVariable[]) {\n        this.variables = newVariables;\n      },\n      menuContainer: null,\n    };\n  },\n\n  addAttributes() {\n    return {\n      variable: {\n        default: null,\n        parseHTML: (element) => {\n          return {\n            id: element.getAttribute(\"data-variable-id\"),\n            label: element.getAttribute(\"data-variable-label\"),\n          };\n        },\n        renderHTML: (attributes) => {\n          if (!attributes.variable) {\n            return {};\n          }\n\n          return {\n            \"data-variable-id\": attributes.variable.id,\n            \"data-variable-label\": attributes.variable.label,\n          };\n        },\n      },\n    };\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `span[data-type=\"${this.name}\"]`,\n      },\n    ];\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      \"span\",\n      mergeAttributes({ \"data-type\": this.name }, HTMLAttributes),\n      `${node.attrs.variable?.label}`,\n    ];\n  },\n\n  renderText({ node }) {\n    const variable = node.attrs.variable as CurlyBracketsVariable;\n    return `${variable.label ?? variable.id}`;\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Backspace: () =>\n        this.editor.commands.command(({ tr, state }) => {\n          let isCurlyBrackets = false;\n          const { selection } = state;\n          const { empty, anchor } = selection;\n\n          if (!empty) {\n            return false;\n          }\n\n          state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {\n            if (node.type.name === this.name) {\n              isCurlyBrackets = true;\n              tr.insertText(CURLY_BRACKETS_SYMBOL, pos, pos + node.nodeSize);\n\n              return false;\n            }\n          });\n\n          return isCurlyBrackets;\n        }),\n    };\n  },\n};\n\nexport const CurlyBrackets = Node.create<\n  CurlyBracketsOptions,\n  CurlyBracketsStorage\n>(curlyBracketsConfig);\n","import { Editor } from \"@tiptap/core\";\nimport { matchSorter } from \"match-sorter\";\n\nimport {\n  CurlyBracketsVariable,\n  CurlyBracketsStorage,\n} from \"./curly-brackets.extension\";\n\nfunction match(variables: readonly CurlyBracketsVariable[], query: string) {\n  return matchSorter(variables, query, {\n    keys: [(option) => option.label],\n    threshold: matchSorter.rankings.ACRONYM,\n  });\n}\n\nexport function getCurlyBracketsSuggestions(\n  editor: Editor,\n  query: string\n): CurlyBracketsVariable[] {\n  const curlyBracketsStorage = editor.storage[\n    \"curly-brackets\"\n  ] as CurlyBracketsStorage;\n  const { variables } = curlyBracketsStorage;\n\n  if (!variables) {\n    return [];\n  }\n\n  return match(variables, query);\n}\n","import { Editor, Extension } from \"@tiptap/core\";\n\nexport type ShiftEnterHandlerOptions = {\n  handler: (props: { editor: Editor }) => boolean | undefined;\n};\n\nexport const ShiftEnterHandler = Extension.create<ShiftEnterHandlerOptions>({\n  name: \"ShiftEnterHandler\",\n  addKeyboardShortcuts() {\n    return {\n      \"Shift-Enter\": (props) => {\n        return this.options.handler(props) ?? false;\n      },\n    };\n  },\n});\n","import Blockquote from \"@tiptap/extension-blockquote\";\nimport Bold from \"@tiptap/extension-bold\";\nimport BulletList from \"@tiptap/extension-bullet-list\";\nimport Code from \"@tiptap/extension-code\";\nimport CodeBlock from \"@tiptap/extension-code-block\";\nimport Gapcursor from \"@tiptap/extension-gapcursor\";\nimport HardBreak from \"@tiptap/extension-hard-break\";\nimport Heading from \"@tiptap/extension-heading\";\nimport HorizontalRule from \"@tiptap/extension-horizontal-rule\";\nimport Italic from \"@tiptap/extension-italic\";\nimport ListItem from \"@tiptap/extension-list-item\";\nimport OrderedList from \"@tiptap/extension-ordered-list\";\nimport Strike from \"@tiptap/extension-strike\";\nimport Underline from \"@tiptap/extension-underline\";\n\nexport const FORMATTING_EXTENSIONS = [\n  Blockquote,\n  Bold,\n  BulletList,\n  Code,\n  CodeBlock,\n  Gapcursor,\n  HardBreak,\n  Heading,\n  HorizontalRule,\n  Italic,\n  ListItem,\n  OrderedList,\n  Strike,\n  Underline,\n];\n","import { Node } from \"@tiptap/core\";\n\nexport const AnyBlockDocument = Node.create({\n  name: \"doc\",\n  topNode: true,\n  content: \"block+\",\n});\n","import { Node } from \"@tiptap/core\";\n\nexport const SingleParagraphDocument = Node.create({\n  name: \"doc\",\n  topNode: true,\n  content: \"paragraph\",\n});\n","import { getSchema } from \"@tiptap/core\";\nimport Paragraph from \"@tiptap/extension-paragraph\";\nimport Text from \"@tiptap/extension-text\";\n\nimport { CurlyBrackets } from \"./extensions/curly-brackets\";\nimport { Link } from \"./extensions/link\";\nimport { Mention } from \"./extensions/mention\";\nimport { FORMATTING_EXTENSIONS } from \"./formatting\";\nimport { AnyBlockDocument } from \"./nodes/document/any-block-document\";\n\nexport const SCHEMA_EXTENSIONS = [\n  AnyBlockDocument,\n  Link,\n  Mention,\n  Paragraph,\n  Text,\n  CurlyBrackets,\n  ...FORMATTING_EXTENSIONS,\n];\n\nexport const schema = getSchema(SCHEMA_EXTENSIONS);\n","// ::- Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\nfunction OrderedMap(content) {\n  this.content = content;\n}\n\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n\n  find: function(key) {\n    for (var i = 0; i < this.content.length; i += 2)\n      if (this.content[i] === key) return i\n    return -1\n  },\n\n  // :: (string) → ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function(key) {\n    var found = this.find(key);\n    return found == -1 ? undefined : this.content[found + 1]\n  },\n\n  // :: (string, any, ?string) → OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found = self.find(key), content = self.content.slice();\n    if (found == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found + 1] = value;\n      if (newKey) content[found] = newKey;\n    }\n    return new OrderedMap(content)\n  },\n\n  // :: (string) → OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function(key) {\n    var found = this.find(key);\n    if (found == -1) return this\n    var content = this.content.slice();\n    content.splice(found, 2);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content))\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, string, any) → OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice();\n    var found = without.find(place);\n    content.splice(found == -1 ? content.length : found, 0, key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function(f) {\n    for (var i = 0; i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1]);\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(map.content.concat(this.subtract(map).content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(this.subtract(map).content.concat(map.content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function(map) {\n    var result = this;\n    map = OrderedMap.from(map);\n    for (var i = 0; i < map.content.length; i += 2)\n      result = result.remove(map.content[i]);\n    return result\n  },\n\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1\n  }\n};\n\n// :: (?union<Object, OrderedMap>) → OrderedMap\n// Return a map with the given content. If null, create an empty\n// map. If given an ordered map, return that map itself. If given an\n// object, create a map from the object's properties.\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap) return value\n  var content = [];\n  if (value) for (var prop in value) content.push(prop, value[prop]);\n  return new OrderedMap(content)\n};\n\nvar orderedmap = OrderedMap;\n\nexport default orderedmap;\n","export function findDiffStart(a, b, pos) {\n  for (let i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      return a.childCount == b.childCount ? null : pos\n\n    let childA = a.child(i), childB = b.child(i)\n    if (childA == childB) { pos += childA.nodeSize; continue }\n\n    if (!childA.sameMarkup(childB)) return pos\n\n    if (childA.isText && childA.text != childB.text) {\n      for (let j = 0; childA.text[j] == childB.text[j]; j++)\n        pos++\n      return pos\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffStart(childA.content, childB.content, pos + 1)\n      if (inner != null) return inner\n    }\n    pos += childA.nodeSize\n  }\n}\n\nexport function findDiffEnd(a, b, posA, posB) {\n  for (let iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0)\n      return iA == iB ? null : {a: posA, b: posB}\n\n    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize\n    if (childA == childB) {\n      posA -= size; posB -= size\n      continue\n    }\n\n    if (!childA.sameMarkup(childB)) return {a: posA, b: posB}\n\n    if (childA.isText && childA.text != childB.text) {\n      let same = 0, minSize = Math.min(childA.text.length, childB.text.length)\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++; posA--; posB--\n      }\n      return {a: posA, b: posB}\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1)\n      if (inner) return inner\n    }\n    posA -= size; posB -= size\n  }\n}\n","import {findDiffStart, findDiffEnd} from \"./diff\"\n\n// ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\nexport class Fragment {\n  constructor(content, size) {\n    this.content = content\n    // :: number\n    // The size of the fragment, which is the total of the size of its\n    // content nodes.\n    this.size = size || 0\n    if (size == null) for (let i = 0; i < content.length; i++)\n      this.size += content[i].nodeSize\n  }\n\n  // :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)\n  // Invoke a callback for all descendant nodes between the given two\n  // positions (relative to start of this fragment). Doesn't descend\n  // into a node when the callback returns `false`.\n  nodesBetween(from, to, f, nodeStart = 0, parent) {\n    for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n        let start = pos + 1\n        child.nodesBetween(Math.max(0, from - start),\n                           Math.min(child.content.size, to - start),\n                           f, nodeStart + start)\n      }\n      pos = end\n    }\n  }\n\n  // :: ((node: Node, pos: number, parent: Node) → ?bool)\n  // Call the given callback for every descendant node. The callback\n  // may return `false` to prevent traversal of a given node's children.\n  descendants(f) {\n    this.nodesBetween(0, this.size, f)\n  }\n\n  // :: (number, number, ?string, ?union<string, (leafNode: Node) → string>) → string\n  // Extract the text between `from` and `to`. See the same method on\n  // [`Node`](#model.Node.textBetween).\n  textBetween(from, to, blockSeparator, leafText) {\n    let text = \"\", separated = true\n    this.nodesBetween(from, to, (node, pos) => {\n      if (node.isText) {\n        text += node.text.slice(Math.max(from, pos) - pos, to - pos)\n        separated = !blockSeparator\n      } else if (node.isLeaf && leafText) {\n        text += typeof leafText === 'function' ? leafText(node): leafText\n        separated = !blockSeparator\n      } else if (!separated && node.isBlock) {\n        text += blockSeparator\n        separated = true\n      }\n    }, 0)\n    return text\n  }\n\n  // :: (Fragment) → Fragment\n  // Create a new fragment containing the combined content of this\n  // fragment and the other.\n  append(other) {\n    if (!other.size) return this\n    if (!this.size) return other\n    let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0\n    if (last.isText && last.sameMarkup(first)) {\n      content[content.length - 1] = last.withText(last.text + first.text)\n      i = 1\n    }\n    for (; i < other.content.length; i++) content.push(other.content[i])\n    return new Fragment(content, this.size + other.size)\n  }\n\n  // :: (number, ?number) → Fragment\n  // Cut out the sub-fragment between the two given positions.\n  cut(from, to) {\n    if (to == null) to = this.size\n    if (from == 0 && to == this.size) return this\n    let result = [], size = 0\n    if (to > from) for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from) {\n        if (pos < from || end > to) {\n          if (child.isText)\n            child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos))\n          else\n            child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1))\n        }\n        result.push(child)\n        size += child.nodeSize\n      }\n      pos = end\n    }\n    return new Fragment(result, size)\n  }\n\n  cutByIndex(from, to) {\n    if (from == to) return Fragment.empty\n    if (from == 0 && to == this.content.length) return this\n    return new Fragment(this.content.slice(from, to))\n  }\n\n  // :: (number, Node) → Fragment\n  // Create a new fragment in which the node at the given index is\n  // replaced by the given node.\n  replaceChild(index, node) {\n    let current = this.content[index]\n    if (current == node) return this\n    let copy = this.content.slice()\n    let size = this.size + node.nodeSize - current.nodeSize\n    copy[index] = node\n    return new Fragment(copy, size)\n  }\n\n  // : (Node) → Fragment\n  // Create a new fragment by prepending the given node to this\n  // fragment.\n  addToStart(node) {\n    return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n  }\n\n  // : (Node) → Fragment\n  // Create a new fragment by appending the given node to this\n  // fragment.\n  addToEnd(node) {\n    return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n  }\n\n  // :: (Fragment) → bool\n  // Compare this fragment to another one.\n  eq(other) {\n    if (this.content.length != other.content.length) return false\n    for (let i = 0; i < this.content.length; i++)\n      if (!this.content[i].eq(other.content[i])) return false\n    return true\n  }\n\n  // :: ?Node\n  // The first child of the fragment, or `null` if it is empty.\n  get firstChild() { return this.content.length ? this.content[0] : null }\n\n  // :: ?Node\n  // The last child of the fragment, or `null` if it is empty.\n  get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null }\n\n  // :: number\n  // The number of child nodes in this fragment.\n  get childCount() { return this.content.length }\n\n  // :: (number) → Node\n  // Get the child node at the given index. Raise an error when the\n  // index is out of range.\n  child(index) {\n    let found = this.content[index]\n    if (!found) throw new RangeError(\"Index \" + index + \" out of range for \" + this)\n    return found\n  }\n\n  // :: (number) → ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) {\n    return this.content[index]\n  }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) {\n    for (let i = 0, p = 0; i < this.content.length; i++) {\n      let child = this.content[i]\n      f(child, p, i)\n      p += child.nodeSize\n    }\n  }\n\n  // :: (Fragment) → ?number\n  // Find the first position at which this fragment and another\n  // fragment differ, or `null` if they are the same.\n  findDiffStart(other, pos = 0) {\n    return findDiffStart(this, other, pos)\n  }\n\n  // :: (Fragment) → ?{a: number, b: number}\n  // Find the first position, searching from the end, at which this\n  // fragment and the given fragment differ, or `null` if they are the\n  // same. Since this position will not be the same in both nodes, an\n  // object with two separate positions is returned.\n  findDiffEnd(other, pos = this.size, otherPos = other.size) {\n    return findDiffEnd(this, other, pos, otherPos)\n  }\n\n  // : (number, ?number) → {index: number, offset: number}\n  // Find the index and inner offset corresponding to a given relative\n  // position in this fragment. The result object will be reused\n  // (overwritten) the next time the function is called. (Not public.)\n  findIndex(pos, round = -1) {\n    if (pos == 0) return retIndex(0, pos)\n    if (pos == this.size) return retIndex(this.content.length, pos)\n    if (pos > this.size || pos < 0) throw new RangeError(`Position ${pos} outside of fragment (${this})`)\n    for (let i = 0, curPos = 0;; i++) {\n      let cur = this.child(i), end = curPos + cur.nodeSize\n      if (end >= pos) {\n        if (end == pos || round > 0) return retIndex(i + 1, end)\n        return retIndex(i, curPos)\n      }\n      curPos = end\n    }\n  }\n\n  // :: () → string\n  // Return a debugging string that describes this fragment.\n  toString() { return \"<\" + this.toStringInner() + \">\" }\n\n  toStringInner() { return this.content.join(\", \") }\n\n  // :: () → ?Object\n  // Create a JSON-serializeable representation of this fragment.\n  toJSON() {\n    return this.content.length ? this.content.map(n => n.toJSON()) : null\n  }\n\n  // :: (Schema, ?Object) → Fragment\n  // Deserialize a fragment from its JSON representation.\n  static fromJSON(schema, value) {\n    if (!value) return Fragment.empty\n    if (!Array.isArray(value)) throw new RangeError(\"Invalid input for Fragment.fromJSON\")\n    return new Fragment(value.map(schema.nodeFromJSON))\n  }\n\n  // :: ([Node]) → Fragment\n  // Build a fragment from an array of nodes. Ensures that adjacent\n  // text nodes with the same marks are joined together.\n  static fromArray(array) {\n    if (!array.length) return Fragment.empty\n    let joined, size = 0\n    for (let i = 0; i < array.length; i++) {\n      let node = array[i]\n      size += node.nodeSize\n      if (i && node.isText && array[i - 1].sameMarkup(node)) {\n        if (!joined) joined = array.slice(0, i)\n        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text)\n      } else if (joined) {\n        joined.push(node)\n      }\n    }\n    return new Fragment(joined || array, size)\n  }\n\n  // :: (?union<Fragment, Node, [Node]>) → Fragment\n  // Create a fragment from something that can be interpreted as a set\n  // of nodes. For `null`, it returns the empty fragment. For a\n  // fragment, the fragment itself. For a node or array of nodes, a\n  // fragment containing those nodes.\n  static from(nodes) {\n    if (!nodes) return Fragment.empty\n    if (nodes instanceof Fragment) return nodes\n    if (Array.isArray(nodes)) return this.fromArray(nodes)\n    if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize)\n    throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" +\n                         (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"))\n  }\n}\n\nconst found = {index: 0, offset: 0}\nfunction retIndex(index, offset) {\n  found.index = index\n  found.offset = offset\n  return found\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0)\n","export function compareDeep(a, b) {\n  if (a === b) return true\n  if (!(a && typeof a == \"object\") ||\n      !(b && typeof b == \"object\")) return false\n  let array = Array.isArray(a)\n  if (Array.isArray(b) != array) return false\n  if (array) {\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++) if (!compareDeep(a[i], b[i])) return false\n  } else {\n    for (let p in a) if (!(p in b) || !compareDeep(a[p], b[p])) return false\n    for (let p in b) if (!(p in a)) return false\n  }\n  return true\n}\n","import {compareDeep} from \"./comparedeep\"\n\n// ::- A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\nexport class Mark {\n  constructor(type, attrs) {\n    // :: MarkType\n    // The type of this mark.\n    this.type = type\n    // :: Object\n    // The attributes associated with this mark.\n    this.attrs = attrs\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Given a set of marks, create a new set which contains this one as\n  // well, in the right position. If this mark is already in the set,\n  // the set itself is returned. If any marks that are set to be\n  // [exclusive](#model.MarkSpec.excludes) with this mark are present,\n  // those are replaced by this one.\n  addToSet(set) {\n    let copy, placed = false\n    for (let i = 0; i < set.length; i++) {\n      let other = set[i]\n      if (this.eq(other)) return set\n      if (this.type.excludes(other.type)) {\n        if (!copy) copy = set.slice(0, i)\n      } else if (other.type.excludes(this.type)) {\n        return set\n      } else {\n        if (!placed && other.type.rank > this.type.rank) {\n          if (!copy) copy = set.slice(0, i)\n          copy.push(this)\n          placed = true\n        }\n        if (copy) copy.push(other)\n      }\n    }\n    if (!copy) copy = set.slice()\n    if (!placed) copy.push(this)\n    return copy\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Remove this mark from the given set, returning a new set. If this\n  // mark is not in the set, the set itself is returned.\n  removeFromSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (this.eq(set[i]))\n        return set.slice(0, i).concat(set.slice(i + 1))\n    return set\n  }\n\n  // :: ([Mark]) → bool\n  // Test whether this mark is in the given set of marks.\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (this.eq(set[i])) return true\n    return false\n  }\n\n  // :: (Mark) → bool\n  // Test whether this mark has the same type and attributes as\n  // another mark.\n  eq(other) {\n    return this == other ||\n      (this.type == other.type && compareDeep(this.attrs, other.attrs))\n  }\n\n  // :: () → Object\n  // Convert this mark to a JSON-serializeable representation.\n  toJSON() {\n    let obj = {type: this.type.name}\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs\n      break\n    }\n    return obj\n  }\n\n  // :: (Schema, Object) → Mark\n  static fromJSON(schema, json) {\n    if (!json) throw new RangeError(\"Invalid input for Mark.fromJSON\")\n    let type = schema.marks[json.type]\n    if (!type) throw new RangeError(`There is no mark type ${json.type} in this schema`)\n    return type.create(json.attrs)\n  }\n\n  // :: ([Mark], [Mark]) → bool\n  // Test whether two sets of marks are identical.\n  static sameSet(a, b) {\n    if (a == b) return true\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++)\n      if (!a[i].eq(b[i])) return false\n    return true\n  }\n\n  // :: (?union<Mark, [Mark]>) → [Mark]\n  // Create a properly sorted mark set from null, a single mark, or an\n  // unsorted array of marks.\n  static setFrom(marks) {\n    if (!marks || marks.length == 0) return Mark.none\n    if (marks instanceof Mark) return [marks]\n    let copy = marks.slice()\n    copy.sort((a, b) => a.type.rank - b.type.rank)\n    return copy\n  }\n}\n\n// :: [Mark] The empty set of marks.\nMark.none = []\n","import {Fragment} from \"./fragment\"\n\n// ReplaceError:: class extends Error\n// Error type raised by [`Node.replace`](#model.Node.replace) when\n// given an invalid replacement.\n\nexport function ReplaceError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = ReplaceError.prototype\n  return err\n}\n\nReplaceError.prototype = Object.create(Error.prototype)\nReplaceError.prototype.constructor = ReplaceError\nReplaceError.prototype.name = \"ReplaceError\"\n\n// ::- A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are ‘open’ (cut through).\nexport class Slice {\n  // :: (Fragment, number, number)\n  // Create a slice. When specifying a non-zero open depth, you must\n  // make sure that there are nodes of at least that depth at the\n  // appropriate side of the fragment—i.e. if the fragment is an empty\n  // paragraph node, `openStart` and `openEnd` can't be greater than 1.\n  //\n  // It is not necessary for the content of open nodes to conform to\n  // the schema's content constraints, though it should be a valid\n  // start/end/middle for such a node, depending on which sides are\n  // open.\n  constructor(content, openStart, openEnd) {\n    // :: Fragment The slice's content.\n    this.content = content\n    // :: number The open depth at the start.\n    this.openStart = openStart\n    // :: number The open depth at the end.\n    this.openEnd = openEnd\n  }\n\n  // :: number\n  // The size this slice would add when inserted into a document.\n  get size() {\n    return this.content.size - this.openStart - this.openEnd\n  }\n\n  insertAt(pos, fragment) {\n    let content = insertInto(this.content, pos + this.openStart, fragment, null)\n    return content && new Slice(content, this.openStart, this.openEnd)\n  }\n\n  removeBetween(from, to) {\n    return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)\n  }\n\n  // :: (Slice) → bool\n  // Tests whether this slice is equal to another slice.\n  eq(other) {\n    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd\n  }\n\n  toString() {\n    return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\"\n  }\n\n  // :: () → ?Object\n  // Convert a slice to a JSON-serializable representation.\n  toJSON() {\n    if (!this.content.size) return null\n    let json = {content: this.content.toJSON()}\n    if (this.openStart > 0) json.openStart = this.openStart\n    if (this.openEnd > 0) json.openEnd = this.openEnd\n    return json\n  }\n\n  // :: (Schema, ?Object) → Slice\n  // Deserialize a slice from its JSON representation.\n  static fromJSON(schema, json) {\n    if (!json) return Slice.empty\n    let openStart = json.openStart || 0, openEnd = json.openEnd || 0\n    if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n      throw new RangeError(\"Invalid input for Slice.fromJSON\")\n    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd)\n  }\n\n  // :: (Fragment, ?bool) → Slice\n  // Create a slice from a fragment by taking the maximum possible\n  // open value on both side of the fragment.\n  static maxOpen(fragment, openIsolating=true) {\n    let openStart = 0, openEnd = 0\n    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) openStart++\n    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild) openEnd++\n    return new Slice(fragment, openStart, openEnd)\n  }\n}\n\nfunction removeRange(content, from, to) {\n  let {index, offset} = content.findIndex(from), child = content.maybeChild(index)\n  let {index: indexTo, offset: offsetTo} = content.findIndex(to)\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError(\"Removing non-flat range\")\n    return content.cut(0, from).append(content.cut(to))\n  }\n  if (index != indexTo) throw new RangeError(\"Removing non-flat range\")\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  let {index, offset} = content.findIndex(dist), child = content.maybeChild(index)\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) return null\n    return content.cut(0, dist).append(insert).append(content.cut(dist))\n  }\n  let inner = insertInto(child.content, dist - offset - 1, insert)\n  return inner && content.replaceChild(index, child.copy(inner))\n}\n\n// :: Slice\n// The empty slice.\nSlice.empty = new Slice(Fragment.empty, 0, 0)\n\nexport function replace($from, $to, slice) {\n  if (slice.openStart > $from.depth)\n    throw new ReplaceError(\"Inserted content deeper than insertion position\")\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n    throw new ReplaceError(\"Inconsistent open depths\")\n  return replaceOuter($from, $to, slice, 0)\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  let index = $from.index(depth), node = $from.node(depth)\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    let inner = replaceOuter($from, $to, slice, depth + 1)\n    return node.copy(node.content.replaceChild(index, inner))\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth))\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n    let parent = $from.parent, content = parent.content\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))\n  } else {\n    let {start, end} = prepareSliceForReplace(slice, $from)\n    return close(node, replaceThreeWay($from, start, end, $to, depth))\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type))\n    throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name)\n}\n\nfunction joinable($before, $after, depth) {\n  let node = $before.node(depth)\n  checkJoin(node, $after.node(depth))\n  return node\n}\n\nfunction addNode(child, target) {\n  let last = target.length - 1\n  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n    target[last] = child.withText(target[last].text + child.text)\n  else\n    target.push(child)\n}\n\nfunction addRange($start, $end, depth, target) {\n  let node = ($end || $start).node(depth)\n  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount\n  if ($start) {\n    startIndex = $start.index(depth)\n    if ($start.depth > depth) {\n      startIndex++\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target)\n      startIndex++\n    }\n  }\n  for (let i = startIndex; i < endIndex; i++) addNode(node.child(i), target)\n  if ($end && $end.depth == depth && $end.textOffset)\n    addNode($end.nodeBefore, target)\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content))\n    throw new ReplaceError(\"Invalid content for node \" + node.type.name)\n  return node.copy(content)\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  let openStart = $from.depth > depth && joinable($from, $start, depth + 1)\n  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1)\n\n  let content = []\n  addRange(null, $from, depth, content)\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd)\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content)\n  } else {\n    if (openStart)\n      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content)\n    addRange($start, $end, depth, content)\n    if (openEnd)\n      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content)\n  }\n  addRange($to, null, depth, content)\n  return new Fragment(content)\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  let content = []\n  addRange(null, $from, depth, content)\n  if ($from.depth > depth) {\n    let type = joinable($from, $to, depth + 1)\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content)\n  }\n  addRange($to, null, depth, content)\n  return new Fragment(content)\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  let extra = $along.depth - slice.openStart, parent = $along.node(extra)\n  let node = parent.copy(slice.content)\n  for (let i = extra - 1; i >= 0; i--)\n    node = $along.node(i).copy(Fragment.from(node))\n  return {start: node.resolveNoCache(slice.openStart + extra),\n          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}\n}\n","import {Mark} from \"./mark\"\n\n// ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\nexport class ResolvedPos {\n  constructor(pos, path, parentOffset) {\n    // :: number The position that was resolved.\n    this.pos = pos\n    this.path = path\n    // :: number\n    // The number of levels the parent node is from the root. If this\n    // position points directly into the root node, it is 0. If it\n    // points into a top-level paragraph, 1, and so on.\n    this.depth = path.length / 3 - 1\n    // :: number The offset this position has into its parent node.\n    this.parentOffset = parentOffset\n  }\n\n  resolveDepth(val) {\n    if (val == null) return this.depth\n    if (val < 0) return this.depth + val\n    return val\n  }\n\n  // :: Node\n  // The parent node that the position points into. Note that even if\n  // a position points into a text node, that node is not considered\n  // the parent—text nodes are ‘flat’ in this model, and have no content.\n  get parent() { return this.node(this.depth) }\n\n  // :: Node\n  // The root node in which the position was resolved.\n  get doc() { return this.node(0) }\n\n  // :: (?number) → Node\n  // The ancestor node at the given level. `p.node(p.depth)` is the\n  // same as `p.parent`.\n  node(depth) { return this.path[this.resolveDepth(depth) * 3] }\n\n  // :: (?number) → number\n  // The index into the ancestor at the given level. If this points at\n  // the 3rd node in the 2nd paragraph on the top level, for example,\n  // `p.index(0)` is 1 and `p.index(1)` is 2.\n  index(depth) { return this.path[this.resolveDepth(depth) * 3 + 1] }\n\n  // :: (?number) → number\n  // The index pointing after this position into the ancestor at the\n  // given level.\n  indexAfter(depth) {\n    depth = this.resolveDepth(depth)\n    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n  }\n\n  // :: (?number) → number\n  // The (absolute) position at the start of the node at the given\n  // level.\n  start(depth) {\n    depth = this.resolveDepth(depth)\n    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n  }\n\n  // :: (?number) → number\n  // The (absolute) position at the end of the node at the given\n  // level.\n  end(depth) {\n    depth = this.resolveDepth(depth)\n    return this.start(depth) + this.node(depth).content.size\n  }\n\n  // :: (?number) → number\n  // The (absolute) position directly before the wrapping node at the\n  // given level, or, when `depth` is `this.depth + 1`, the original\n  // position.\n  before(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position before the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n  }\n\n  // :: (?number) → number\n  // The (absolute) position directly after the wrapping node at the\n  // given level, or the original position when `depth` is `this.depth + 1`.\n  after(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position after the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n  }\n\n  // :: number\n  // When this position points into a text node, this returns the\n  // distance between the position and the start of the text node.\n  // Will be zero for positions that point between nodes.\n  get textOffset() { return this.pos - this.path[this.path.length - 1] }\n\n  // :: ?Node\n  // Get the node directly after the position, if any. If the position\n  // points into a text node, only the part of that node after the\n  // position is returned.\n  get nodeAfter() {\n    let parent = this.parent, index = this.index(this.depth)\n    if (index == parent.childCount) return null\n    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index)\n    return dOff ? parent.child(index).cut(dOff) : child\n  }\n\n  // :: ?Node\n  // Get the node directly before the position, if any. If the\n  // position points into a text node, only the part of that node\n  // before the position is returned.\n  get nodeBefore() {\n    let index = this.index(this.depth)\n    let dOff = this.pos - this.path[this.path.length - 1]\n    if (dOff) return this.parent.child(index).cut(0, dOff)\n    return index == 0 ? null : this.parent.child(index - 1)\n  }\n\n  // :: (number, ?number) → number\n  // Get the position at the given index in the parent node at the\n  // given depth (which defaults to `this.depth`).\n  posAtIndex(index, depth) {\n    depth = this.resolveDepth(depth)\n    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n    for (let i = 0; i < index; i++) pos += node.child(i).nodeSize\n    return pos\n  }\n\n  // :: () → [Mark]\n  // Get the marks at this position, factoring in the surrounding\n  // marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n  // position is at the start of a non-empty node, the marks of the\n  // node after it (if any) are returned.\n  marks() {\n    let parent = this.parent, index = this.index()\n\n    // In an empty parent, return the empty array\n    if (parent.content.size == 0) return Mark.none\n\n    // When inside a text node, just return the text node's marks\n    if (this.textOffset) return parent.child(index).marks\n\n    let main = parent.maybeChild(index - 1), other = parent.maybeChild(index)\n    // If the `after` flag is true of there is no node before, make\n    // the node after this position the main reference.\n    if (!main) { let tmp = main; main = other; other = tmp }\n\n    // Use all marks in the main node, except those that have\n    // `inclusive` set to false and are not present in the other node.\n    let marks = main.marks\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n        marks = marks[i--].removeFromSet(marks)\n\n    return marks\n  }\n\n  // :: (ResolvedPos) → ?[Mark]\n  // Get the marks after the current position, if any, except those\n  // that are non-inclusive and not present at position `$end`. This\n  // is mostly useful for getting the set of marks to preserve after a\n  // deletion. Will return `null` if this position is at the end of\n  // its parent node or its parent node isn't a textblock (in which\n  // case no marks should be preserved).\n  marksAcross($end) {\n    let after = this.parent.maybeChild(this.index())\n    if (!after || !after.isInline) return null\n\n    let marks = after.marks, next = $end.parent.maybeChild($end.index())\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n        marks = marks[i--].removeFromSet(marks)\n    return marks\n  }\n\n  // :: (number) → number\n  // The depth up to which this position and the given (non-resolved)\n  // position share the same parent nodes.\n  sharedDepth(pos) {\n    for (let depth = this.depth; depth > 0; depth--)\n      if (this.start(depth) <= pos && this.end(depth) >= pos) return depth\n    return 0\n  }\n\n  // :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange\n  // Returns a range based on the place where this position and the\n  // given position diverge around block content. If both point into\n  // the same textblock, for example, a range around that textblock\n  // will be returned. If they point into different blocks, the range\n  // around those blocks in their shared ancestor is returned. You can\n  // pass in an optional predicate that will be called with a parent\n  // node to see if a range into that parent is acceptable.\n  blockRange(other = this, pred) {\n    if (other.pos < this.pos) return other.blockRange(this)\n    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n        return new NodeRange(this, other, d)\n  }\n\n  // :: (ResolvedPos) → bool\n  // Query whether the given position shares the same parent node.\n  sameParent(other) {\n    return this.pos - this.parentOffset == other.pos - other.parentOffset\n  }\n\n  // :: (ResolvedPos) → ResolvedPos\n  // Return the greater of this and the given position.\n  max(other) {\n    return other.pos > this.pos ? other : this\n  }\n\n  // :: (ResolvedPos) → ResolvedPos\n  // Return the smaller of this and the given position.\n  min(other) {\n    return other.pos < this.pos ? other : this\n  }\n\n  toString() {\n    let str = \"\"\n    for (let i = 1; i <= this.depth; i++)\n      str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1)\n    return str + \":\" + this.parentOffset\n  }\n\n  static resolve(doc, pos) {\n    if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError(\"Position \" + pos + \" out of range\")\n    let path = []\n    let start = 0, parentOffset = pos\n    for (let node = doc;;) {\n      let {index, offset} = node.content.findIndex(parentOffset)\n      let rem = parentOffset - offset\n      path.push(node, index, start + offset)\n      if (!rem) break\n      node = node.child(index)\n      if (node.isText) break\n      parentOffset = rem - 1\n      start += offset + 1\n    }\n    return new ResolvedPos(pos, path, parentOffset)\n  }\n\n  static resolveCached(doc, pos) {\n    for (let i = 0; i < resolveCache.length; i++) {\n      let cached = resolveCache[i]\n      if (cached.pos == pos && cached.doc == doc) return cached\n    }\n    let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos)\n    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize\n    return result\n  }\n}\n\nlet resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12\n\n// ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\nexport class NodeRange {\n  // :: (ResolvedPos, ResolvedPos, number)\n  // Construct a node range. `$from` and `$to` should point into the\n  // same node until at least the given `depth`, since a node range\n  // denotes an adjacent set of nodes in a single parent node.\n  constructor($from, $to, depth) {\n    // :: ResolvedPos A resolved position along the start of the\n    // content. May have a `depth` greater than this object's `depth`\n    // property, since these are the positions that were used to\n    // compute the range, not re-resolved positions directly at its\n    // boundaries.\n    this.$from = $from\n    // :: ResolvedPos A position along the end of the content. See\n    // caveat for [`$from`](#model.NodeRange.$from).\n    this.$to = $to\n    // :: number The depth of the node that this range points into.\n    this.depth = depth\n  }\n\n  // :: number The position at the start of the range.\n  get start() { return this.$from.before(this.depth + 1) }\n  // :: number The position at the end of the range.\n  get end() { return this.$to.after(this.depth + 1) }\n\n  // :: Node The parent node that the range points into.\n  get parent() { return this.$from.node(this.depth) }\n  // :: number The start index of the range in the parent node.\n  get startIndex() { return this.$from.index(this.depth) }\n  // :: number The end index of the range in the parent node.\n  get endIndex() { return this.$to.indexAfter(this.depth) }\n}\n","import {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {Slice, replace} from \"./replace\"\nimport {ResolvedPos} from \"./resolvedpos\"\nimport {compareDeep} from \"./comparedeep\"\n\nconst emptyAttrs = Object.create(null)\n\n// ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\nexport class Node {\n  constructor(type, attrs, content, marks) {\n    // :: NodeType\n    // The type of node that this is.\n    this.type = type\n\n    // :: Object\n    // An object mapping attribute names to values. The kind of\n    // attributes allowed and required are\n    // [determined](#model.NodeSpec.attrs) by the node type.\n    this.attrs = attrs\n\n    // :: Fragment\n    // A container holding the node's children.\n    this.content = content || Fragment.empty\n\n    // :: [Mark]\n    // The marks (things like whether it is emphasized or part of a\n    // link) applied to this node.\n    this.marks = marks || Mark.none\n  }\n\n  // text:: ?string\n  // For text nodes, this contains the node's text content.\n\n  // :: number\n  // The size of this node, as defined by the integer-based [indexing\n  // scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n  // amount of characters. For other leaf nodes, it is one. For\n  // non-leaf nodes, it is the size of the content plus two (the start\n  // and end token).\n  get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size }\n\n  // :: number\n  // The number of children that the node has.\n  get childCount() { return this.content.childCount }\n\n  // :: (number) → Node\n  // Get the child node at the given index. Raises an error when the\n  // index is out of range.\n  child(index) { return this.content.child(index) }\n\n  // :: (number) → ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) { return this.content.maybeChild(index) }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) { this.content.forEach(f) }\n\n  // :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)\n  // Invoke a callback for all descendant nodes recursively between\n  // the given two positions that are relative to start of this node's\n  // content. The callback is invoked with the node, its\n  // parent-relative position, its parent node, and its child index.\n  // When the callback returns false for a given node, that node's\n  // children will not be recursed over. The last parameter can be\n  // used to specify a starting position to count from.\n  nodesBetween(from, to, f, startPos = 0) {\n    this.content.nodesBetween(from, to, f, startPos, this)\n  }\n\n  // :: ((node: Node, pos: number, parent: Node, index: number) → ?bool)\n  // Call the given callback for every descendant node. Doesn't\n  // descend into a node when the callback returns `false`.\n  descendants(f) {\n    this.nodesBetween(0, this.content.size, f)\n  }\n\n  // :: string\n  // Concatenates all the text nodes found in this fragment and its\n  // children.\n  get textContent() { return this.textBetween(0, this.content.size, \"\") }\n\n  // :: (number, number, ?string, ?union<string, ?(leafNode: Node) -> string>) → string\n  // Get all text between positions `from` and `to`. When\n  // `blockSeparator` is given, it will be inserted to separate text\n  // from different block nodes. When `leafText` is given, it'll be\n  // inserted for every non-text leaf node encountered.\n  textBetween(from, to, blockSeparator, leafText) {\n    return this.content.textBetween(from, to, blockSeparator, leafText)\n  }\n\n  // :: ?Node\n  // Returns this node's first child, or `null` if there are no\n  // children.\n  get firstChild() { return this.content.firstChild }\n\n  // :: ?Node\n  // Returns this node's last child, or `null` if there are no\n  // children.\n  get lastChild() { return this.content.lastChild }\n\n  // :: (Node) → bool\n  // Test whether two nodes represent the same piece of document.\n  eq(other) {\n    return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n  }\n\n  // :: (Node) → bool\n  // Compare the markup (type, attributes, and marks) of this node to\n  // those of another. Returns `true` if both have the same markup.\n  sameMarkup(other) {\n    return this.hasMarkup(other.type, other.attrs, other.marks)\n  }\n\n  // :: (NodeType, ?Object, ?[Mark]) → bool\n  // Check whether this node's markup correspond to the given type,\n  // attributes, and marks.\n  hasMarkup(type, attrs, marks) {\n    return this.type == type &&\n      compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n      Mark.sameSet(this.marks, marks || Mark.none)\n  }\n\n  // :: (?Fragment) → Node\n  // Create a new node with the same markup as this node, containing\n  // the given content (or empty, if no content is given).\n  copy(content = null) {\n    if (content == this.content) return this\n    return new this.constructor(this.type, this.attrs, content, this.marks)\n  }\n\n  // :: ([Mark]) → Node\n  // Create a copy of this node, with the given set of marks instead\n  // of the node's own marks.\n  mark(marks) {\n    return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n  }\n\n  // :: (number, ?number) → Node\n  // Create a copy of this node with only the content between the\n  // given positions. If `to` is not given, it defaults to the end of\n  // the node.\n  cut(from, to) {\n    if (from == 0 && to == this.content.size) return this\n    return this.copy(this.content.cut(from, to))\n  }\n\n  // :: (number, ?number) → Slice\n  // Cut out the part of the document between the given positions, and\n  // return it as a `Slice` object.\n  slice(from, to = this.content.size, includeParents = false) {\n    if (from == to) return Slice.empty\n\n    let $from = this.resolve(from), $to = this.resolve(to)\n    let depth = includeParents ? 0 : $from.sharedDepth(to)\n    let start = $from.start(depth), node = $from.node(depth)\n    let content = node.content.cut($from.pos - start, $to.pos - start)\n    return new Slice(content, $from.depth - depth, $to.depth - depth)\n  }\n\n  // :: (number, number, Slice) → Node\n  // Replace the part of the document between the given positions with\n  // the given slice. The slice must 'fit', meaning its open sides\n  // must be able to connect to the surrounding content, and its\n  // content nodes must be valid children for the node they are placed\n  // into. If any of this is violated, an error of type\n  // [`ReplaceError`](#model.ReplaceError) is thrown.\n  replace(from, to, slice) {\n    return replace(this.resolve(from), this.resolve(to), slice)\n  }\n\n  // :: (number) → ?Node\n  // Find the node directly after the given position.\n  nodeAt(pos) {\n    for (let node = this;;) {\n      let {index, offset} = node.content.findIndex(pos)\n      node = node.maybeChild(index)\n      if (!node) return null\n      if (offset == pos || node.isText) return node\n      pos -= offset + 1\n    }\n  }\n\n  // :: (number) → {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node after the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childAfter(pos) {\n    let {index, offset} = this.content.findIndex(pos)\n    return {node: this.content.maybeChild(index), index, offset}\n  }\n\n  // :: (number) → {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node before the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childBefore(pos) {\n    if (pos == 0) return {node: null, index: 0, offset: 0}\n    let {index, offset} = this.content.findIndex(pos)\n    if (offset < pos) return {node: this.content.child(index), index, offset}\n    let node = this.content.child(index - 1)\n    return {node, index: index - 1, offset: offset - node.nodeSize}\n  }\n\n  // :: (number) → ResolvedPos\n  // Resolve the given position in the document, returning an\n  // [object](#model.ResolvedPos) with information about its context.\n  resolve(pos) { return ResolvedPos.resolveCached(this, pos) }\n\n  resolveNoCache(pos) { return ResolvedPos.resolve(this, pos) }\n\n  // :: (number, number, union<Mark, MarkType>) → bool\n  // Test whether a given mark or mark type occurs in this document\n  // between the two given positions.\n  rangeHasMark(from, to, type) {\n    let found = false\n    if (to > from) this.nodesBetween(from, to, node => {\n      if (type.isInSet(node.marks)) found = true\n      return !found\n    })\n    return found\n  }\n\n  // :: bool\n  // True when this is a block (non-inline node)\n  get isBlock() { return this.type.isBlock }\n\n  // :: bool\n  // True when this is a textblock node, a block node with inline\n  // content.\n  get isTextblock() { return this.type.isTextblock }\n\n  // :: bool\n  // True when this node allows inline content.\n  get inlineContent() { return this.type.inlineContent }\n\n  // :: bool\n  // True when this is an inline node (a text node or a node that can\n  // appear among text).\n  get isInline() { return this.type.isInline }\n\n  // :: bool\n  // True when this is a text node.\n  get isText() { return this.type.isText }\n\n  // :: bool\n  // True when this is a leaf node.\n  get isLeaf() { return this.type.isLeaf }\n\n  // :: bool\n  // True when this is an atom, i.e. when it does not have directly\n  // editable content. This is usually the same as `isLeaf`, but can\n  // be configured with the [`atom` property](#model.NodeSpec.atom) on\n  // a node's spec (typically used when the node is displayed as an\n  // uneditable [node view](#view.NodeView)).\n  get isAtom() { return this.type.isAtom }\n\n  // :: () → string\n  // Return a string representation of this node for debugging\n  // purposes.\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    let name = this.type.name\n    if (this.content.size)\n      name += \"(\" + this.content.toStringInner() + \")\"\n    return wrapMarks(this.marks, name)\n  }\n\n  // :: (number) → ContentMatch\n  // Get the content match in this node at the given index.\n  contentMatchAt(index) {\n    let match = this.type.contentMatch.matchFragment(this.content, 0, index)\n    if (!match) throw new Error(\"Called contentMatchAt on a node with invalid content\")\n    return match\n  }\n\n  // :: (number, number, ?Fragment, ?number, ?number) → bool\n  // Test whether replacing the range between `from` and `to` (by\n  // child index) with the given replacement fragment (which defaults\n  // to the empty fragment) would leave the node's content valid. You\n  // can optionally pass `start` and `end` indices into the\n  // replacement fragment.\n  canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n    let one = this.contentMatchAt(from).matchFragment(replacement, start, end)\n    let two = one && one.matchFragment(this.content, to)\n    if (!two || !two.validEnd) return false\n    for (let i = start; i < end; i++) if (!this.type.allowsMarks(replacement.child(i).marks)) return false\n    return true\n  }\n\n  // :: (number, number, NodeType, ?[Mark]) → bool\n  // Test whether replacing the range `from` to `to` (by index) with a\n  // node of the given type would leave the node's content valid.\n  canReplaceWith(from, to, type, marks) {\n    if (marks && !this.type.allowsMarks(marks)) return false\n    let start = this.contentMatchAt(from).matchType(type)\n    let end = start && start.matchFragment(this.content, to)\n    return end ? end.validEnd : false\n  }\n\n  // :: (Node) → bool\n  // Test whether the given node's content could be appended to this\n  // node. If that node is empty, this will only return true if there\n  // is at least one node type that can appear in both nodes (to avoid\n  // merging completely incompatible nodes).\n  canAppend(other) {\n    if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content)\n    else return this.type.compatibleContent(other.type)\n  }\n\n  // :: ()\n  // Check whether this node and its descendants conform to the\n  // schema, and raise error when they do not.\n  check() {\n    if (!this.type.validContent(this.content))\n      throw new RangeError(`Invalid content for node ${this.type.name}: ${this.content.toString().slice(0, 50)}`)\n    let copy = Mark.none\n    for (let i = 0; i < this.marks.length; i++) copy = this.marks[i].addToSet(copy)\n    if (!Mark.sameSet(copy, this.marks))\n      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(m => m.type.name)}`)\n    this.content.forEach(node => node.check())\n  }\n\n  // :: () → Object\n  // Return a JSON-serializeable representation of this node.\n  toJSON() {\n    let obj = {type: this.type.name}\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs\n      break\n    }\n    if (this.content.size)\n      obj.content = this.content.toJSON()\n    if (this.marks.length)\n      obj.marks = this.marks.map(n => n.toJSON())\n    return obj\n  }\n\n  // :: (Schema, Object) → Node\n  // Deserialize a node from its JSON representation.\n  static fromJSON(schema, json) {\n    if (!json) throw new RangeError(\"Invalid input for Node.fromJSON\")\n    let marks = null\n    if (json.marks) {\n      if (!Array.isArray(json.marks)) throw new RangeError(\"Invalid mark data for Node.fromJSON\")\n      marks = json.marks.map(schema.markFromJSON)\n    }\n    if (json.type == \"text\") {\n      if (typeof json.text != \"string\") throw new RangeError(\"Invalid text node in JSON\")\n      return schema.text(json.text, marks)\n    }\n    let content = Fragment.fromJSON(schema, json.content)\n    return schema.nodeType(json.type).create(json.attrs, content, marks)\n  }\n}\n\nexport class TextNode extends Node {\n  constructor(type, attrs, content, marks) {\n    super(type, attrs, null, marks)\n\n    if (!content) throw new RangeError(\"Empty text nodes are not allowed\")\n\n    this.text = content\n  }\n\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    return wrapMarks(this.marks, JSON.stringify(this.text))\n  }\n\n  get textContent() { return this.text }\n\n  textBetween(from, to) { return this.text.slice(from, to) }\n\n  get nodeSize() { return this.text.length }\n\n  mark(marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)\n  }\n\n  withText(text) {\n    if (text == this.text) return this\n    return new TextNode(this.type, this.attrs, text, this.marks)\n  }\n\n  cut(from = 0, to = this.text.length) {\n    if (from == 0 && to == this.text.length) return this\n    return this.withText(this.text.slice(from, to))\n  }\n\n  eq(other) {\n    return this.sameMarkup(other) && this.text == other.text\n  }\n\n  toJSON() {\n    let base = super.toJSON()\n    base.text = this.text\n    return base\n  }\n}\n\nfunction wrapMarks(marks, str) {\n  for (let i = marks.length - 1; i >= 0; i--)\n    str = marks[i].type.name + \"(\" + str + \")\"\n  return str\n}\n","import {Fragment} from \"./fragment\"\n\n// ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\nexport class ContentMatch {\n  constructor(validEnd) {\n    // :: bool\n    // True when this match state represents a valid end of the node.\n    this.validEnd = validEnd\n    this.next = []\n    this.wrapCache = []\n  }\n\n  static parse(string, nodeTypes) {\n    let stream = new TokenStream(string, nodeTypes)\n    if (stream.next == null) return ContentMatch.empty\n    let expr = parseExpr(stream)\n    if (stream.next) stream.err(\"Unexpected trailing text\")\n    let match = dfa(nfa(expr))\n    checkForDeadEnds(match, stream)\n    return match\n  }\n\n  // :: (NodeType) → ?ContentMatch\n  // Match a node type, returning a match after that node if\n  // successful.\n  matchType(type) {\n    for (let i = 0; i < this.next.length; i += 2)\n      if (this.next[i] == type) return this.next[i + 1]\n    return null\n  }\n\n  // :: (Fragment, ?number, ?number) → ?ContentMatch\n  // Try to match a fragment. Returns the resulting match when\n  // successful.\n  matchFragment(frag, start = 0, end = frag.childCount) {\n    let cur = this\n    for (let i = start; cur && i < end; i++)\n      cur = cur.matchType(frag.child(i).type)\n    return cur\n  }\n\n  get inlineContent() {\n    let first = this.next[0]\n    return first ? first.isInline : false\n  }\n\n  // :: ?NodeType\n  // Get the first matching node type at this match position that can\n  // be generated.\n  get defaultType() {\n    for (let i = 0; i < this.next.length; i += 2) {\n      let type = this.next[i]\n      if (!(type.isText || type.hasRequiredAttrs())) return type\n    }\n  }\n\n  compatible(other) {\n    for (let i = 0; i < this.next.length; i += 2)\n      for (let j = 0; j < other.next.length; j += 2)\n        if (this.next[i] == other.next[j]) return true\n    return false\n  }\n\n  // :: (Fragment, bool, ?number) → ?Fragment\n  // Try to match the given fragment, and if that fails, see if it can\n  // be made to match by inserting nodes in front of it. When\n  // successful, return a fragment of inserted nodes (which may be\n  // empty if nothing had to be inserted). When `toEnd` is true, only\n  // return a fragment if the resulting match goes to the end of the\n  // content expression.\n  fillBefore(after, toEnd = false, startIndex = 0) {\n    let seen = [this]\n    function search(match, types) {\n      let finished = match.matchFragment(after, startIndex)\n      if (finished && (!toEnd || finished.validEnd))\n        return Fragment.from(types.map(tp => tp.createAndFill()))\n\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i], next = match.next[i + 1]\n        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n          seen.push(next)\n          let found = search(next, types.concat(type))\n          if (found) return found\n        }\n      }\n    }\n\n    return search(this, [])\n  }\n\n  // :: (NodeType) → ?[NodeType]\n  // Find a set of wrapping node types that would allow a node of the\n  // given type to appear at this position. The result may be empty\n  // (when it fits directly) and will be null when no such wrapping\n  // exists.\n  findWrapping(target) {\n    for (let i = 0; i < this.wrapCache.length; i += 2)\n      if (this.wrapCache[i] == target) return this.wrapCache[i + 1]\n    let computed = this.computeWrapping(target)\n    this.wrapCache.push(target, computed)\n    return computed\n  }\n\n  computeWrapping(target) {\n    let seen = Object.create(null), active = [{match: this, type: null, via: null}]\n    while (active.length) {\n      let current = active.shift(), match = current.match\n      if (match.matchType(target)) {\n        let result = []\n        for (let obj = current; obj.type; obj = obj.via)\n          result.push(obj.type)\n        return result.reverse()\n      }\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i]\n        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n          active.push({match: type.contentMatch, type, via: current})\n          seen[type.name] = true\n        }\n      }\n    }\n  }\n\n  // :: number\n  // The number of outgoing edges this node has in the finite\n  // automaton that describes the content expression.\n  get edgeCount() {\n    return this.next.length >> 1\n  }\n\n  // :: (number) → {type: NodeType, next: ContentMatch}\n  // Get the _n_​th outgoing edge from this node in the finite\n  // automaton that describes the content expression.\n  edge(n) {\n    let i = n << 1\n    if (i >= this.next.length) throw new RangeError(`There's no ${n}th edge in this content match`)\n    return {type: this.next[i], next: this.next[i + 1]}\n  }\n\n  toString() {\n    let seen = []\n    function scan(m) {\n      seen.push(m)\n      for (let i = 1; i < m.next.length; i += 2)\n        if (seen.indexOf(m.next[i]) == -1) scan(m.next[i])\n    }\n    scan(this)\n    return seen.map((m, i) => {\n      let out = i + (m.validEnd ? \"*\" : \" \") + \" \"\n      for (let i = 0; i < m.next.length; i += 2)\n        out += (i ? \", \" : \"\") + m.next[i].name + \"->\" + seen.indexOf(m.next[i + 1])\n      return out\n    }).join(\"\\n\")\n  }\n}\n\nContentMatch.empty = new ContentMatch(true)\n\nclass TokenStream {\n  constructor(string, nodeTypes) {\n    this.string = string\n    this.nodeTypes = nodeTypes\n    this.inline = null\n    this.pos = 0\n    this.tokens = string.split(/\\s*(?=\\b|\\W|$)/)\n    if (this.tokens[this.tokens.length - 1] == \"\") this.tokens.pop()\n    if (this.tokens[0] == \"\") this.tokens.shift()\n  }\n\n  get next() { return this.tokens[this.pos] }\n\n  eat(tok) { return this.next == tok && (this.pos++ || true) }\n\n  err(str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\") }\n}\n\nfunction parseExpr(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSeq(stream)) }\n  while (stream.eat(\"|\"))\n  return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n}\n\nfunction parseExprSeq(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSubscript(stream)) }\n  while (stream.next && stream.next != \")\" && stream.next != \"|\")\n  return exprs.length == 1 ? exprs[0] : {type: \"seq\", exprs}\n}\n\nfunction parseExprSubscript(stream) {\n  let expr = parseExprAtom(stream)\n  for (;;) {\n    if (stream.eat(\"+\"))\n      expr = {type: \"plus\", expr}\n    else if (stream.eat(\"*\"))\n      expr = {type: \"star\", expr}\n    else if (stream.eat(\"?\"))\n      expr = {type: \"opt\", expr}\n    else if (stream.eat(\"{\"))\n      expr = parseExprRange(stream, expr)\n    else break\n  }\n  return expr\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) stream.err(\"Expected number, got '\" + stream.next + \"'\")\n  let result = Number(stream.next)\n  stream.pos++\n  return result\n}\n\nfunction parseExprRange(stream, expr) {\n  let min = parseNum(stream), max = min\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") max = parseNum(stream)\n    else max = -1\n  }\n  if (!stream.eat(\"}\")) stream.err(\"Unclosed braced range\")\n  return {type: \"range\", min, max, expr}\n}\n\nfunction resolveName(stream, name) {\n  let types = stream.nodeTypes, type = types[name]\n  if (type) return [type]\n  let result = []\n  for (let typeName in types) {\n    let type = types[typeName]\n    if (type.groups.indexOf(name) > -1) result.push(type)\n  }\n  if (result.length == 0) stream.err(\"No node type or group '\" + name + \"' found\")\n  return result\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    let expr = parseExpr(stream)\n    if (!stream.eat(\")\")) stream.err(\"Missing closing paren\")\n    return expr\n  } else if (!/\\W/.test(stream.next)) {\n    let exprs = resolveName(stream, stream.next).map(type => {\n      if (stream.inline == null) stream.inline = type.isInline\n      else if (stream.inline != type.isInline) stream.err(\"Mixing inline and block content\")\n      return {type: \"name\", value: type}\n    })\n    stream.pos++\n    return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\")\n  }\n}\n\n// The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n\n// : (Object) → [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n  let nfa = [[]]\n  connect(compile(expr, 0), node())\n  return nfa\n\n  function node() { return nfa.push([]) - 1 }\n  function edge(from, to, term) {\n    let edge = {term, to}\n    nfa[from].push(edge)\n    return edge\n  }\n  function connect(edges, to) { edges.forEach(edge => edge.to = to) }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce((out, expr) => out.concat(compile(expr, from)), [])\n    } else if (expr.type == \"seq\") {\n      for (let i = 0;; i++) {\n        let next = compile(expr.exprs[i], from)\n        if (i == expr.exprs.length - 1) return next\n        connect(next, from = node())\n      }\n    } else if (expr.type == \"star\") {\n      let loop = node()\n      edge(from, loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"plus\") {\n      let loop = node()\n      connect(compile(expr.expr, from), loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from))\n    } else if (expr.type == \"range\") {\n      let cur = from\n      for (let i = 0; i < expr.min; i++) {\n        let next = node()\n        connect(compile(expr.expr, cur), next)\n        cur = next\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur)\n      } else {\n        for (let i = expr.min; i < expr.max; i++) {\n          let next = node()\n          edge(cur, next)\n          connect(compile(expr.expr, cur), next)\n          cur = next\n        }\n      }\n      return [edge(cur)]\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)]\n    }\n  }\n}\n\nfunction cmp(a, b) { return b - a }\n\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n  let result = []\n  scan(node)\n  return result.sort(cmp)\n\n  function scan(node) {\n    let edges = nfa[node]\n    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to)\n    result.push(node)\n    for (let i = 0; i < edges.length; i++) {\n      let {term, to} = edges[i]\n      if (!term && result.indexOf(to) == -1) scan(to)\n    }\n  }\n}\n\n// : ([[{term: ?any, to: number}]]) → ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n  let labeled = Object.create(null)\n  return explore(nullFrom(nfa, 0))\n\n  function explore(states) {\n    let out = []\n    states.forEach(node => {\n      nfa[node].forEach(({term, to}) => {\n        if (!term) return\n        let known = out.indexOf(term), set = known > -1 && out[known + 1]\n        nullFrom(nfa, to).forEach(node => {\n          if (!set) out.push(term, set = [])\n          if (set.indexOf(node) == -1) set.push(node)\n        })\n      })\n    })\n    let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1)\n    for (let i = 0; i < out.length; i += 2) {\n      let states = out[i + 1].sort(cmp)\n      state.next.push(out[i], labeled[states.join(\",\")] || explore(states))\n    }\n    return state\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (let i = 0, work = [match]; i < work.length; i++) {\n    let state = work[i], dead = !state.validEnd, nodes = []\n    for (let j = 0; j < state.next.length; j += 2) {\n      let node = state.next[j], next = state.next[j + 1]\n      nodes.push(node.name)\n      if (dead && !(node.isText || node.hasRequiredAttrs())) dead = false\n      if (work.indexOf(next) == -1) work.push(next)\n    }\n    if (dead) stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\")\n  }\n}\n","import OrderedMap from \"orderedmap\"\n\nimport {Node, TextNode} from \"./node\"\nimport {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {ContentMatch} from \"./content\"\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  let defaults = Object.create(null)\n  for (let attrName in attrs) {\n    let attr = attrs[attrName]\n    if (!attr.hasDefault) return null\n    defaults[attrName] = attr.default\n  }\n  return defaults\n}\n\nfunction computeAttrs(attrs, value) {\n  let built = Object.create(null)\n  for (let name in attrs) {\n    let given = value && value[name]\n    if (given === undefined) {\n      let attr = attrs[name]\n      if (attr.hasDefault) given = attr.default\n      else throw new RangeError(\"No value supplied for attribute \" + name)\n    }\n    built[name] = given\n  }\n  return built\n}\n\nfunction initAttrs(attrs) {\n  let result = Object.create(null)\n  if (attrs) for (let name in attrs) result[name] = new Attribute(attrs[name])\n  return result\n}\n\n// ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\nexport class NodeType {\n  constructor(name, schema, spec) {\n    // :: string\n    // The name the node type has in this schema.\n    this.name = name\n\n    // :: Schema\n    // A link back to the `Schema` the node type belongs to.\n    this.schema = schema\n\n    // :: NodeSpec\n    // The spec that this type is based on\n    this.spec = spec\n\n    this.groups = spec.group ? spec.group.split(\" \") : []\n    this.attrs = initAttrs(spec.attrs)\n\n    this.defaultAttrs = defaultAttrs(this.attrs)\n\n    // :: ContentMatch\n    // The starting match of the node type's content expression.\n    this.contentMatch = null\n\n    // : ?[MarkType]\n    // The set of marks allowed in this node. `null` means all marks\n    // are allowed.\n    this.markSet = null\n\n    // :: bool\n    // True if this node type has inline content.\n    this.inlineContent = null\n\n    // :: bool\n    // True if this is a block type\n    this.isBlock = !(spec.inline || name == \"text\")\n\n    // :: bool\n    // True if this is the text node type.\n    this.isText = name == \"text\"\n  }\n\n  // :: bool\n  // True if this is an inline type.\n  get isInline() { return !this.isBlock }\n\n  // :: bool\n  // True if this is a textblock type, a block that contains inline\n  // content.\n  get isTextblock() { return this.isBlock && this.inlineContent }\n\n  // :: bool\n  // True for node types that allow no content.\n  get isLeaf() { return this.contentMatch == ContentMatch.empty }\n\n  // :: bool\n  // True when this node is an atom, i.e. when it does not have\n  // directly editable content.\n  get isAtom() { return this.isLeaf || this.spec.atom }\n\n  // :: union<\"pre\", \"normal\">\n  // The node type's [whitespace](#view.NodeSpec.whitespace) option.\n  get whitespace() { return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\") }\n\n  // :: () → bool\n  // Tells you whether this node type has any required attributes.\n  hasRequiredAttrs() {\n    for (let n in this.attrs) if (this.attrs[n].isRequired) return true\n    return false\n  }\n\n  compatibleContent(other) {\n    return this == other || this.contentMatch.compatible(other.contentMatch)\n  }\n\n  computeAttrs(attrs) {\n    if (!attrs && this.defaultAttrs) return this.defaultAttrs\n    else return computeAttrs(this.attrs, attrs)\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a `Node` of this type. The given attributes are\n  // checked and defaulted (you can pass `null` to use the type's\n  // defaults entirely, if no required attributes exist). `content`\n  // may be a `Fragment`, a node, an array of nodes, or\n  // `null`. Similarly `marks` may be `null` to default to the empty\n  // set of marks.\n  create(attrs, content, marks) {\n    if (this.isText) throw new Error(\"NodeType.create can't construct text nodes\")\n    return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Like [`create`](#model.NodeType.create), but check the given content\n  // against the node type's content restrictions, and throw an error\n  // if it doesn't match.\n  createChecked(attrs, content, marks) {\n    content = Fragment.from(content)\n    if (!this.validContent(content))\n      throw new RangeError(\"Invalid content for node \" + this.name)\n    return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node\n  // Like [`create`](#model.NodeType.create), but see if it is necessary to\n  // add nodes to the start or end of the given fragment to make it\n  // fit the node. If no fitting wrapping can be found, return null.\n  // Note that, due to the fact that required nodes can always be\n  // created, this will always succeed if you pass null or\n  // `Fragment.empty` as content.\n  createAndFill(attrs, content, marks) {\n    attrs = this.computeAttrs(attrs)\n    content = Fragment.from(content)\n    if (content.size) {\n      let before = this.contentMatch.fillBefore(content)\n      if (!before) return null\n      content = before.append(content)\n    }\n    let after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true)\n    if (!after) return null\n    return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n  }\n\n  // :: (Fragment) → bool\n  // Returns true if the given fragment is valid content for this node\n  // type with the given attributes.\n  validContent(content) {\n    let result = this.contentMatch.matchFragment(content)\n    if (!result || !result.validEnd) return false\n    for (let i = 0; i < content.childCount; i++)\n      if (!this.allowsMarks(content.child(i).marks)) return false\n    return true\n  }\n\n  // :: (MarkType) → bool\n  // Check whether the given mark type is allowed in this node.\n  allowsMarkType(markType) {\n    return this.markSet == null || this.markSet.indexOf(markType) > -1\n  }\n\n  // :: ([Mark]) → bool\n  // Test whether the given set of marks are allowed in this node.\n  allowsMarks(marks) {\n    if (this.markSet == null) return true\n    for (let i = 0; i < marks.length; i++) if (!this.allowsMarkType(marks[i].type)) return false\n    return true\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Removes the marks that are not allowed in this node from the given set.\n  allowedMarks(marks) {\n    if (this.markSet == null) return marks\n    let copy\n    for (let i = 0; i < marks.length; i++) {\n      if (!this.allowsMarkType(marks[i].type)) {\n        if (!copy) copy = marks.slice(0, i)\n      } else if (copy) {\n        copy.push(marks[i])\n      }\n    }\n    return !copy ? marks : copy.length ? copy : Mark.empty\n  }\n\n  static compile(nodes, schema) {\n    let result = Object.create(null)\n    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec))\n\n    let topType = schema.spec.topNode || \"doc\"\n    if (!result[topType]) throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\")\n    if (!result.text) throw new RangeError(\"Every schema needs a 'text' type\")\n    for (let _ in result.text.attrs) throw new RangeError(\"The text node type should not have attributes\")\n\n    return result\n  }\n}\n\n// Attribute descriptors\n\nclass Attribute {\n  constructor(options) {\n    this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\")\n    this.default = options.default\n  }\n\n  get isRequired() {\n    return !this.hasDefault\n  }\n}\n\n// Marks\n\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\nexport class MarkType {\n  constructor(name, rank, schema, spec) {\n    // :: string\n    // The name of the mark type.\n    this.name = name\n\n    // :: Schema\n    // The schema that this mark type instance is part of.\n    this.schema = schema\n\n    // :: MarkSpec\n    // The spec on which the type is based.\n    this.spec = spec\n\n    this.attrs = initAttrs(spec.attrs)\n\n    this.rank = rank\n    this.excluded = null\n    let defaults = defaultAttrs(this.attrs)\n    this.instance = defaults && new Mark(this, defaults)\n  }\n\n  // :: (?Object) → Mark\n  // Create a mark of this type. `attrs` may be `null` or an object\n  // containing only some of the mark's attributes. The others, if\n  // they have defaults, will be added.\n  create(attrs) {\n    if (!attrs && this.instance) return this.instance\n    return new Mark(this, computeAttrs(this.attrs, attrs))\n  }\n\n  static compile(marks, schema) {\n    let result = Object.create(null), rank = 0\n    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec))\n    return result\n  }\n\n  // :: ([Mark]) → [Mark]\n  // When there is a mark of this type in the given set, a new set\n  // without it is returned. Otherwise, the input set is returned.\n  removeFromSet(set) {\n    for (var i = 0; i < set.length; i++) if (set[i].type == this) {\n      set = set.slice(0, i).concat(set.slice(i + 1))\n      i--\n    }\n    return set\n  }\n\n  // :: ([Mark]) → ?Mark\n  // Tests whether there is a mark of this type in the given set.\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (set[i].type == this) return set[i]\n  }\n\n  // :: (MarkType) → bool\n  // Queries whether a given mark type is\n  // [excluded](#model.MarkSpec.excludes) by this one.\n  excludes(other) {\n    return this.excluded.indexOf(other) > -1\n  }\n}\n\n// SchemaSpec:: interface\n// An object describing a schema, as passed to the [`Schema`](#model.Schema)\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to\n//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type\n//   associated with that name. Their order is significant—it\n//   determines which [parse rules](#model.NodeSpec.parseDOM) take\n//   precedence by default, and which nodes come first in a given\n//   [group](#model.NodeSpec.group).\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema. The order in which they\n//   are provided determines the order in which [mark\n//   sets](#model.Mark.addToSet) are sorted and in which [parse\n//   rules](#model.MarkSpec.parseDOM) are tried.\n//\n//   topNode:: ?string\n//   The name of the default top-level node for the schema. Defaults\n//   to `\"doc\"`.\n\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](/docs/guide/#schema.content_expressions). When not given,\n//   the node does not allow any content.\n//\n//   marks:: ?string\n//   The marks that are allowed inside of this node. May be a\n//   space-separated string referring to mark names or groups, `\"_\"`\n//   to explicitly allow all marks, or `\"\"` to disallow marks. When\n//   not given, nodes with inline content default to allowing all\n//   marks, other nodes default to not allowing marks.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs,\n//   which can be referred to in the content expressions for the\n//   schema.\n//\n//   inline:: ?bool\n//   Should be set to true for inline nodes. (Implied for text nodes.)\n//\n//   atom:: ?bool\n//   Can be set to true to indicate that, though this isn't a [leaf\n//   node](#model.NodeType.isLeaf), it doesn't have directly editable\n//   content and should be treated as a single unit in the view.\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected as a [node\n//   selection](#state.NodeSelection). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged without\n//   being selected. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   whitespace:: ?union<\"pre\", \"normal\">\n//   Controls way whitespace in this a node is parsed. The default is\n//   `\"normal\"`, which causes the [DOM parser](#model.DOMParser) to\n//   collapse whitespace in normal mode, and normalize it (replacing\n//   newlines and such with spaces) otherwise. `\"pre\"` causes the\n//   parser to preserve spaces inside the node. When this option isn't\n//   given, but [`code`](#model.NodeSpec.code) is true, `whitespace`\n//   will default to `\"pre\"`. Note that this option doesn't influence\n//   the way the node is rendered—that should be handled by `toDOM`\n//   and/or styling.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, in _inserted_ content the defining parents of the\n//   content are preserved when possible. Typically,\n//   non-default-paragraph textblock types, and possibly list items,\n//   are marked as defining.\n//\n//   isolating:: ?bool\n//   When enabled (default is false), the sides of nodes of this type\n//   count as boundaries that regular editing operations, like\n//   backspacing or lifting, won't cross. An example of a node that\n//   should probably have this enabled is a table cell.\n//\n//   toDOM:: ?(node: Node) → DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).\n//   Should return a DOM node or an [array\n//   structure](#model.DOMOutputSpec) that describes one, with an\n//   optional number zero (“hole”) in it to indicate where the node's\n//   content should be inserted.\n//\n//   For text nodes, the default is to create a text DOM node. Though\n//   it is possible to create a serializer where text is rendered\n//   differently, this is not supported inside the editor, so you\n//   shouldn't override that in your text node spec.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n//\n//   toDebugString:: ?(node: Node) -> string\n//   Defines the default way a node of this type should be serialized\n//   to a string representation for debugging (e.g. in error messages).\n\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusive:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at its end (or at its start when that is also the start of the\n//   parent node). Defaults to true.\n//\n//   excludes:: ?string\n//   Determines which other marks this mark can coexist with. Should\n//   be a space-separated strings naming other marks or groups of marks.\n//   When a mark is [added](#model.Mark.addToSet) to a set, all marks\n//   that it excludes are removed in the process. If the set contains\n//   any mark that excludes the new mark but is not, itself, excluded\n//   by the new mark, the mark can not be added an the set. You can\n//   use the value `\"_\"` to indicate that the mark excludes all\n//   marks in the schema.\n//\n//   Defaults to only being exclusive with marks of the same type. You\n//   can set it to an empty string (or any string not containing the\n//   mark's own name) to allow multiple marks of a given type to\n//   coexist (as long as they have different attributes).\n//\n//   group:: ?string\n//   The group or space-separated groups to which this mark belongs.\n//\n//   spanning:: ?bool\n//   Determines whether marks of this type can span multiple adjacent\n//   nodes when serialized to DOM/HTML. Defaults to true.\n//\n//   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML. When the resulting spec contains a hole, that is\n//   where the marked content is placed. Otherwise, it is appended to\n//   the top node.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The\n//   `mark` field in the rules is implied.\n\n// AttributeSpec:: interface\n//\n// Used to [define](#model.NodeSpec.attrs) attributes on nodes or\n// marks.\n//\n//   default:: ?any\n//   The default value for this attribute, to use when no explicit\n//   value is provided. Attributes that have no default must be\n//   provided whenever a node or mark of a type that has them is\n//   created.\n\n// ::- A document schema. Holds [node](#model.NodeType) and [mark\n// type](#model.MarkType) objects for the nodes and marks that may\n// occur in conforming documents, and provides functionality for\n// creating and deserializing such documents.\nexport class Schema {\n  // :: (SchemaSpec)\n  // Construct a schema from a schema [specification](#model.SchemaSpec).\n  constructor(spec) {\n    // :: SchemaSpec\n    // The [spec](#model.SchemaSpec) on which the schema is based,\n    // with the added guarantee that its `nodes` and `marks`\n    // properties are\n    // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances\n    // (not raw objects).\n    this.spec = {}\n    for (let prop in spec) this.spec[prop] = spec[prop]\n    this.spec.nodes = OrderedMap.from(spec.nodes)\n    this.spec.marks = OrderedMap.from(spec.marks)\n\n    // :: Object<NodeType>\n    // An object mapping the schema's node names to node type objects.\n    this.nodes = NodeType.compile(this.spec.nodes, this)\n\n    // :: Object<MarkType>\n    // A map from mark names to mark type objects.\n    this.marks = MarkType.compile(this.spec.marks, this)\n\n    let contentExprCache = Object.create(null)\n    for (let prop in this.nodes) {\n      if (prop in this.marks)\n        throw new RangeError(prop + \" can not be both a node and a mark\")\n      let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks\n      type.contentMatch = contentExprCache[contentExpr] ||\n        (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes))\n      type.inlineContent = type.contentMatch.inlineContent\n      type.markSet = markExpr == \"_\" ? null :\n        markExpr ? gatherMarks(this, markExpr.split(\" \")) :\n        markExpr == \"\" || !type.inlineContent ? [] : null\n    }\n    for (let prop in this.marks) {\n      let type = this.marks[prop], excl = type.spec.excludes\n      type.excluded = excl == null ? [type] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"))\n    }\n\n    this.nodeFromJSON = this.nodeFromJSON.bind(this)\n    this.markFromJSON = this.markFromJSON.bind(this)\n\n    // :: NodeType\n    // The type of the [default top node](#model.SchemaSpec.topNode)\n    // for this schema.\n    this.topNodeType = this.nodes[this.spec.topNode || \"doc\"]\n\n    // :: Object\n    // An object for storing whatever values modules may want to\n    // compute and cache per schema. (If you want to store something\n    // in it, try to use property names unlikely to clash.)\n    this.cached = Object.create(null)\n    this.cached.wrappings = Object.create(null)\n  }\n\n  // :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a node in this schema. The `type` may be a string or a\n  // `NodeType` instance. Attributes will be extended\n  // with defaults, `content` may be a `Fragment`,\n  // `null`, a `Node`, or an array of nodes.\n  node(type, attrs, content, marks) {\n    if (typeof type == \"string\")\n      type = this.nodeType(type)\n    else if (!(type instanceof NodeType))\n      throw new RangeError(\"Invalid node type: \" + type)\n    else if (type.schema != this)\n      throw new RangeError(\"Node type from different schema used (\" + type.name + \")\")\n\n    return type.createChecked(attrs, content, marks)\n  }\n\n  // :: (string, ?[Mark]) → Node\n  // Create a text node in the schema. Empty text nodes are not\n  // allowed.\n  text(text, marks) {\n    let type = this.nodes.text\n    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks))\n  }\n\n  // :: (union<string, MarkType>, ?Object) → Mark\n  // Create a mark with the given type and attributes.\n  mark(type, attrs) {\n    if (typeof type == \"string\") type = this.marks[type]\n    return type.create(attrs)\n  }\n\n  // :: (Object) → Node\n  // Deserialize a node from its JSON representation. This method is\n  // bound.\n  nodeFromJSON(json) {\n    return Node.fromJSON(this, json)\n  }\n\n  // :: (Object) → Mark\n  // Deserialize a mark from its JSON representation. This method is\n  // bound.\n  markFromJSON(json) {\n    return Mark.fromJSON(this, json)\n  }\n\n  nodeType(name) {\n    let found = this.nodes[name]\n    if (!found) throw new RangeError(\"Unknown node type: \" + name)\n    return found\n  }\n}\n\nfunction gatherMarks(schema, marks) {\n  let found = []\n  for (let i = 0; i < marks.length; i++) {\n    let name = marks[i], mark = schema.marks[name], ok = mark\n    if (mark) {\n      found.push(mark)\n    } else {\n      for (let prop in schema.marks) {\n        let mark = schema.marks[prop]\n        if (name == \"_\" || (mark.spec.group && mark.spec.group.split(\" \").indexOf(name) > -1))\n          found.push(ok = mark)\n      }\n    }\n    if (!ok) throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\")\n  }\n  return found\n}\n","import {Fragment} from \"./fragment\"\nimport {Slice} from \"./replace\"\nimport {Mark} from \"./mark\"\n\n// ParseOptions:: interface\n// These are the options recognized by the\n// [`parse`](#model.DOMParser.parse) and\n// [`parseSlice`](#model.DOMParser.parseSlice) methods.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   `true` to preserve whitespace, but normalize newlines to\n//   spaces, and `\"full\"` to preserve whitespace entirely.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into the schema's default\n//   [top node type](#model.Schema.topNodeType). You can pass this\n//   option to use the type and attributes from a different node\n//   as the top container.\n//\n//   topMatch:: ?ContentMatch\n//   Provide the starting content match that content parsed into the\n//   top node is matched against.\n//\n//   context:: ?ResolvedPos\n//   A set of additional nodes to count as\n//   [context](#model.ParseRule.context) when parsing, above the\n//   given [top node](#model.ParseOptions.topNode).\n\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   namespace:: ?string\n//   The namespace to match. This should be used with `tag`.\n//   Nodes are only matched when the namespace matches or this property\n//   is null.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property. May also have the form\n//   `\"property=value\"`, in which case the rule only matches if the\n//   property's value exactly matches the given value. (For more\n//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)\n//   and return false to indicate that the match failed.) Rules\n//   matching styles may only produce [marks](#model.ParseRule.mark),\n//   not nodes.\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schema—when directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   consuming:: ?boolean\n//   By default, when a rule matches an element or style, no further\n//   rules get a chance to match it. By setting this to `false`, you\n//   indicate that even when this rule matches, other rules that come\n//   after it should also run.\n//\n//   context:: ?string\n//   When given, restricts this rule to only match when the current\n//   context—the parent nodes into which the content is being\n//   parsed—matches this expression. Should contain one or more node\n//   names or node group names followed by single or double slashes.\n//   For example `\"paragraph/\"` means the rule only matches when the\n//   parent node is a paragraph, `\"blockquote/paragraph/\"` restricts\n//   it to be in a paragraph that is inside a blockquote, and\n//   `\"section//\"` matches any position inside a section—a double\n//   slash matches any sequence of ancestor nodes. To allow multiple\n//   different contexts, they can be separated by a pipe (`|`)\n//   character, as in `\"blockquote/|list_item/\"`.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   closeParent:: ?bool\n//   When true, finding an element that matches this rule will close\n//   the current node.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?union<string, (dom.Node) → dom.Node>\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element, or a function that returns the actual content\n//   element to the parser.\n//\n//   getContent:: ?(dom.Node, schema: Schema) → Fragment\n//   Can be used to override the content of a matched node. When\n//   present, instead of parsing the node's child nodes, the result of\n//   this function is used.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element. `false` means whitespace may\n//   be collapsed, `true` means that whitespace should be preserved\n//   but newlines normalized to spaces, and `\"full\"` means that\n//   newlines should also be preserved.\n\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\nexport class DOMParser {\n  // :: (Schema, [ParseRule])\n  // Create a parser that targets the given schema, using the given\n  // parsing rules.\n  constructor(schema, rules) {\n    // :: Schema\n    // The schema into which the parser parses.\n    this.schema = schema\n    // :: [ParseRule]\n    // The set of [parse rules](#model.ParseRule) that the parser\n    // uses, in order of precedence.\n    this.rules = rules\n    this.tags = []\n    this.styles = []\n\n    rules.forEach(rule => {\n      if (rule.tag) this.tags.push(rule)\n      else if (rule.style) this.styles.push(rule)\n    })\n\n    // Only normalize list elements when lists in the schema can't directly contain themselves\n    this.normalizeLists = !this.tags.some(r => {\n      if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) return false\n      let node = schema.nodes[r.node]\n      return node.contentMatch.matchType(node)\n    })\n  }\n\n  // :: (dom.Node, ?ParseOptions) → Node\n  // Parse a document from the content of a DOM node.\n  parse(dom, options = {}) {\n    let context = new ParseContext(this, options, false)\n    context.addAll(dom, null, options.from, options.to)\n    return context.finish()\n  }\n\n  // :: (dom.Node, ?ParseOptions) → Slice\n  // Parses the content of the given DOM node, like\n  // [`parse`](#model.DOMParser.parse), and takes the same set of\n  // options. But unlike that method, which produces a whole node,\n  // this one returns a slice that is open at the sides, meaning that\n  // the schema constraints aren't applied to the start of nodes to\n  // the left of the input and the end of nodes at the end.\n  parseSlice(dom, options = {}) {\n    let context = new ParseContext(this, options, true)\n    context.addAll(dom, null, options.from, options.to)\n    return Slice.maxOpen(context.finish())\n  }\n\n  matchTag(dom, context, after) {\n    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n      let rule = this.tags[i]\n      if (matches(dom, rule.tag) &&\n          (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n          (!rule.context || context.matchesContext(rule.context))) {\n        if (rule.getAttrs) {\n          let result = rule.getAttrs(dom)\n          if (result === false) continue\n          rule.attrs = result\n        }\n        return rule\n      }\n    }\n  }\n\n  matchStyle(prop, value, context, after) {\n    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n      let rule = this.styles[i]\n      if (rule.style.indexOf(prop) != 0 ||\n          rule.context && !context.matchesContext(rule.context) ||\n          // Test that the style string either precisely matches the prop,\n          // or has an '=' sign after the prop, followed by the given\n          // value.\n          rule.style.length > prop.length &&\n          (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))\n        continue\n      if (rule.getAttrs) {\n        let result = rule.getAttrs(value)\n        if (result === false) continue\n        rule.attrs = result\n      }\n      return rule\n    }\n  }\n\n  // : (Schema) → [ParseRule]\n  static schemaRules(schema) {\n    let result = []\n    function insert(rule) {\n      let priority = rule.priority == null ? 50 : rule.priority, i = 0\n      for (; i < result.length; i++) {\n        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority\n        if (nextPriority < priority) break\n      }\n      result.splice(i, 0, rule)\n    }\n\n    for (let name in schema.marks) {\n      let rules = schema.marks[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.mark = name\n      })\n    }\n    for (let name in schema.nodes) {\n      let rules = schema.nodes[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.node = name\n      })\n    }\n    return result\n  }\n\n  // :: (Schema) → DOMParser\n  // Construct a DOM parser using the parsing rules listed in a\n  // schema's [node specs](#model.NodeSpec.parseDOM), reordered by\n  // [priority](#model.ParseRule.priority).\n  static fromSchema(schema) {\n    return schema.cached.domParser ||\n      (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))\n  }\n}\n\n// : Object<bool> The block-level tags in HTML5\nconst blockTags = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n}\n\n// : Object<bool> The tags that we normally ignore.\nconst ignoreTags = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n}\n\n// : Object<bool> List tags.\nconst listTags = {ol: true, ul: true}\n\n// Using a bitfield for node context options\nconst OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4\n\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n  if (preserveWhitespace != null) return (preserveWhitespace ? OPT_PRESERVE_WS : 0) |\n    (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0)\n  return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT\n}\n\nclass NodeContext {\n  constructor(type, attrs, marks, pendingMarks, solid, match, options) {\n    this.type = type\n    this.attrs = attrs\n    this.solid = solid\n    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch)\n    this.options = options\n    this.content = []\n    // Marks applied to this node itself\n    this.marks = marks\n    // Marks applied to its children\n    this.activeMarks = Mark.none\n    // Marks that can't apply here, but will be used in children if possible\n    this.pendingMarks = pendingMarks\n    // Nested Marks with same type\n    this.stashMarks = []\n  }\n\n  findWrapping(node) {\n    if (!this.match) {\n      if (!this.type) return []\n      let fill = this.type.contentMatch.fillBefore(Fragment.from(node))\n      if (fill) {\n        this.match = this.type.contentMatch.matchFragment(fill)\n      } else {\n        let start = this.type.contentMatch, wrap\n        if (wrap = start.findWrapping(node.type)) {\n          this.match = start\n          return wrap\n        } else {\n          return null\n        }\n      }\n    }\n    return this.match.findWrapping(node.type)\n  }\n\n  finish(openEnd) {\n    if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n      let last = this.content[this.content.length - 1], m\n      if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n        if (last.text.length == m[0].length) this.content.pop()\n        else this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length))\n      }\n    }\n    let content = Fragment.from(this.content)\n    if (!openEnd && this.match)\n      content = content.append(this.match.fillBefore(Fragment.empty, true))\n    return this.type ? this.type.create(this.attrs, content, this.marks) : content\n  }\n\n  popFromStashMark(mark) {\n    for (let i = this.stashMarks.length - 1; i >= 0; i--)\n      if (mark.eq(this.stashMarks[i])) return this.stashMarks.splice(i, 1)[0]\n  }\n\n  applyPending(nextType) {\n    for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n      let mark = pending[i]\n      if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&\n          !mark.isInSet(this.activeMarks)) {\n        this.activeMarks = mark.addToSet(this.activeMarks)\n        this.pendingMarks = mark.removeFromSet(this.pendingMarks)\n      }\n    }\n  }\n\n  inlineContext(node) {\n    if (this.type) return this.type.inlineContent\n    if (this.content.length) return this.content[0].isInline\n    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase())\n  }\n}\n\nclass ParseContext {\n  // : (DOMParser, Object)\n  constructor(parser, options, open) {\n    // : DOMParser The parser we are using.\n    this.parser = parser\n    // : Object The options passed to this parse.\n    this.options = options\n    this.isOpen = open\n    let topNode = options.topNode, topContext\n    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (open ? OPT_OPEN_LEFT : 0)\n    if (topNode)\n      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,\n                                   options.topMatch || topNode.type.contentMatch, topOptions)\n    else if (open)\n      topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions)\n    else\n      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions)\n    this.nodes = [topContext]\n    // : [Mark] The current set of marks\n    this.open = 0\n    this.find = options.findPositions\n    this.needsBlock = false\n  }\n\n  get top() {\n    return this.nodes[this.open]\n  }\n\n  // : (dom.Node)\n  // Add a DOM node to the content. Text is inserted as text node,\n  // otherwise, the node is passed to `addElement` or, if it has a\n  // `style` attribute, `addElementWithStyles`.\n  addDOM(dom) {\n    if (dom.nodeType == 3) {\n      this.addTextNode(dom)\n    } else if (dom.nodeType == 1) {\n      let style = dom.getAttribute(\"style\")\n      let marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.addPendingMark(marks[i])\n      this.addElement(dom)\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.removePendingMark(marks[i], top)\n    }\n  }\n\n  addTextNode(dom) {\n    let value = dom.nodeValue\n    let top = this.top\n    if (top.options & OPT_PRESERVE_WS_FULL ||\n        top.inlineContext(dom) ||\n        /[^ \\t\\r\\n\\u000c]/.test(value)) {\n      if (!(top.options & OPT_PRESERVE_WS)) {\n        value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \")\n        // If this starts with whitespace, and there is no node before it, or\n        // a hard break, or a text node that ends with whitespace, strip the\n        // leading space.\n        if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n          let nodeBefore = top.content[top.content.length - 1]\n          let domNodeBefore = dom.previousSibling\n          if (!nodeBefore ||\n              (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n              (nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)))\n            value = value.slice(1)\n        }\n      } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n        value = value.replace(/\\r?\\n|\\r/g, \" \")\n      } else {\n        value = value.replace(/\\r\\n?/g, \"\\n\")\n      }\n      if (value) this.insertNode(this.parser.schema.text(value))\n      this.findInText(dom)\n    } else {\n      this.findInside(dom)\n    }\n  }\n\n  // : (dom.Element, ?ParseRule)\n  // Try to find a handler for the given tag and use that to parse. If\n  // none is found, the element's content nodes are added directly.\n  addElement(dom, matchAfter) {\n    let name = dom.nodeName.toLowerCase(), ruleID\n    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom)\n    let rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||\n        (ruleID = this.parser.matchTag(dom, this, matchAfter))\n    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n      this.findInside(dom)\n      this.ignoreFallback(dom)\n    } else if (!rule || rule.skip || rule.closeParent) {\n      if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1)\n      else if (rule && rule.skip.nodeType) dom = rule.skip\n      let sync, top = this.top, oldNeedsBlock = this.needsBlock\n      if (blockTags.hasOwnProperty(name)) {\n        sync = true\n        if (!top.type) this.needsBlock = true\n      } else if (!dom.firstChild) {\n        this.leafFallback(dom)\n        return\n      }\n      this.addAll(dom)\n      if (sync) this.sync(top)\n      this.needsBlock = oldNeedsBlock\n    } else {\n      this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null)\n    }\n  }\n\n  // Called for leaf DOM nodes that would otherwise be ignored\n  leafFallback(dom) {\n    if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n      this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"))\n  }\n\n  // Called for ignored nodes\n  ignoreFallback(dom) {\n    // Ignored BR nodes should at least create an inline context\n    if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n      this.findPlace(this.parser.schema.text(\"-\"))\n  }\n\n  // Run any style parser associated with the node's styles. Either\n  // return an array of marks, or null to indicate some of the styles\n  // had a rule with `ignore` set.\n  readStyles(styles) {\n    let marks = Mark.none\n    style: for (let i = 0; i < styles.length; i += 2) {\n      for (let after = null;;) {\n        let rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after)\n        if (!rule) continue style\n        if (rule.ignore) return null\n        marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks)\n        if (rule.consuming === false) after = rule\n        else break\n      }\n    }\n    return marks\n  }\n\n  // : (dom.Element, ParseRule) → bool\n  // Look up a handler for the given node. If none are found, return\n  // false. Otherwise, apply it, use its return value to drive the way\n  // the node's content is wrapped, and return true.\n  addElementByRule(dom, rule, continueAfter) {\n    let sync, nodeType, markType, mark\n    if (rule.node) {\n      nodeType = this.parser.schema.nodes[rule.node]\n      if (!nodeType.isLeaf) {\n        sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace)\n      } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n        this.leafFallback(dom)\n      }\n    } else {\n      markType = this.parser.schema.marks[rule.mark]\n      mark = markType.create(rule.attrs)\n      this.addPendingMark(mark)\n    }\n    let startIn = this.top\n\n    if (nodeType && nodeType.isLeaf) {\n      this.findInside(dom)\n    } else if (continueAfter) {\n      this.addElement(dom, continueAfter)\n    } else if (rule.getContent) {\n      this.findInside(dom)\n      rule.getContent(dom, this.parser.schema).forEach(node => this.insertNode(node))\n    } else {\n      let contentDOM = rule.contentElement\n      if (typeof contentDOM == \"string\") contentDOM = dom.querySelector(contentDOM)\n      else if (typeof contentDOM == \"function\") contentDOM = contentDOM(dom)\n      if (!contentDOM) contentDOM = dom\n      this.findAround(dom, contentDOM, true)\n      this.addAll(contentDOM, sync)\n    }\n    if (sync) { this.sync(startIn); this.open-- }\n    if (mark) this.removePendingMark(mark, startIn)\n  }\n\n  // : (dom.Node, ?NodeBuilder, ?number, ?number)\n  // Add all child nodes between `startIndex` and `endIndex` (or the\n  // whole node, if not given). If `sync` is passed, use it to\n  // synchronize after every block element.\n  addAll(parent, sync, startIndex, endIndex) {\n    let index = startIndex || 0\n    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n             end = endIndex == null ? null : parent.childNodes[endIndex];\n         dom != end; dom = dom.nextSibling, ++index) {\n      this.findAtPoint(parent, index)\n      this.addDOM(dom)\n      if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n        this.sync(sync)\n    }\n    this.findAtPoint(parent, index)\n  }\n\n  // Try to find a way to fit the given node type into the current\n  // context. May add intermediate wrappers and/or leave non-solid\n  // nodes that we're in.\n  findPlace(node) {\n    let route, sync\n    for (let depth = this.open; depth >= 0; depth--) {\n      let cx = this.nodes[depth]\n      let found = cx.findWrapping(node)\n      if (found && (!route || route.length > found.length)) {\n        route = found\n        sync = cx\n        if (!found.length) break\n      }\n      if (cx.solid) break\n    }\n    if (!route) return false\n    this.sync(sync)\n    for (let i = 0; i < route.length; i++)\n      this.enterInner(route[i], null, false)\n    return true\n  }\n\n  // : (Node) → ?Node\n  // Try to insert the given node, adjusting the context when needed.\n  insertNode(node) {\n    if (node.isInline && this.needsBlock && !this.top.type) {\n      let block = this.textblockFromContext()\n      if (block) this.enterInner(block)\n    }\n    if (this.findPlace(node)) {\n      this.closeExtra()\n      let top = this.top\n      top.applyPending(node.type)\n      if (top.match) top.match = top.match.matchType(node.type)\n      let marks = top.activeMarks\n      for (let i = 0; i < node.marks.length; i++)\n        if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n          marks = node.marks[i].addToSet(marks)\n      top.content.push(node.mark(marks))\n      return true\n    }\n    return false\n  }\n\n  // : (NodeType, ?Object) → bool\n  // Try to start a node of the given type, adjusting the context when\n  // necessary.\n  enter(type, attrs, preserveWS) {\n    let ok = this.findPlace(type.create(attrs))\n    if (ok) this.enterInner(type, attrs, true, preserveWS)\n    return ok\n  }\n\n  // Open a node of the given type\n  enterInner(type, attrs, solid, preserveWS) {\n    this.closeExtra()\n    let top = this.top\n    top.applyPending(type)\n    top.match = top.match && top.match.matchType(type, attrs)\n    let options = wsOptionsFor(type, preserveWS, top.options)\n    if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) options |= OPT_OPEN_LEFT\n    this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options))\n    this.open++\n  }\n\n  // Make sure all nodes above this.open are finished and added to\n  // their parents\n  closeExtra(openEnd) {\n    let i = this.nodes.length - 1\n    if (i > this.open) {\n      for (; i > this.open; i--) this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd))\n      this.nodes.length = this.open + 1\n    }\n  }\n\n  finish() {\n    this.open = 0\n    this.closeExtra(this.isOpen)\n    return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n  }\n\n  sync(to) {\n    for (let i = this.open; i >= 0; i--) if (this.nodes[i] == to) {\n      this.open = i\n      return\n    }\n  }\n\n  get currentPos() {\n    this.closeExtra()\n    let pos = 0\n    for (let i = this.open; i >= 0; i--) {\n      let content = this.nodes[i].content\n      for (let j = content.length - 1; j >= 0; j--)\n        pos += content[j].nodeSize\n      if (i) pos++\n    }\n    return pos\n  }\n\n  findAtPoint(parent, offset) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == parent && this.find[i].offset == offset)\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findInside(parent) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findAround(parent, content, before) {\n    if (parent != content && this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n        let pos = content.compareDocumentPosition(this.find[i].node)\n        if (pos & (before ? 2 : 4))\n          this.find[i].pos = this.currentPos\n      }\n    }\n  }\n\n  findInText(textNode) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == textNode)\n        this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset)\n    }\n  }\n\n  // : (string) → bool\n  // Determines whether the given [context\n  // string](#ParseRule.context) matches this context.\n  matchesContext(context) {\n    if (context.indexOf(\"|\") > -1)\n      return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this)\n\n    let parts = context.split(\"/\")\n    let option = this.options.context\n    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type)\n    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1)\n    let match = (i, depth) => {\n      for (; i >= 0; i--) {\n        let part = parts[i]\n        if (part == \"\") {\n          if (i == parts.length - 1 || i == 0) continue\n          for (; depth >= minDepth; depth--)\n            if (match(i - 1, depth)) return true\n          return false\n        } else {\n          let next = depth > 0 || (depth == 0 && useRoot) ? this.nodes[depth].type\n              : option && depth >= minDepth ? option.node(depth - minDepth).type\n              : null\n          if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n            return false\n          depth--\n        }\n      }\n      return true\n    }\n    return match(parts.length - 1, this.open)\n  }\n\n  textblockFromContext() {\n    let $context = this.options.context\n    if ($context) for (let d = $context.depth; d >= 0; d--) {\n      let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType\n      if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt\n    }\n    for (let name in this.parser.schema.nodes) {\n      let type = this.parser.schema.nodes[name]\n      if (type.isTextblock && type.defaultAttrs) return type\n    }\n  }\n\n  addPendingMark(mark) {\n    let found = findSameMarkInSet(mark, this.top.pendingMarks)\n    if (found) this.top.stashMarks.push(found)\n    this.top.pendingMarks = mark.addToSet(this.top.pendingMarks)\n  }\n\n  removePendingMark(mark, upto) {\n    for (let depth = this.open; depth >= 0; depth--) {\n      let level = this.nodes[depth]\n      let found = level.pendingMarks.lastIndexOf(mark)\n      if (found > -1) {\n        level.pendingMarks = mark.removeFromSet(level.pendingMarks)\n      } else {\n        level.activeMarks = mark.removeFromSet(level.activeMarks)\n        let stashMark = level.popFromStashMark(mark)\n        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))\n          level.activeMarks = stashMark.addToSet(level.activeMarks)\n      }\n      if (level == upto) break\n    }\n  }\n}\n\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child)\n      child = prevItem\n    } else if (name == \"li\") {\n      prevItem = child\n    } else if (name) {\n      prevItem = null\n    }\n  }\n}\n\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)\n}\n\n// : (string) → [string]\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n  let re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = []\n  while (m = re.exec(style)) result.push(m[1], m[2].trim())\n  return result\n}\n\nfunction copy(obj) {\n  let copy = {}\n  for (let prop in obj) copy[prop] = obj[prop]\n  return copy\n}\n\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n  let nodes = nodeType.schema.nodes\n  for (let name in nodes) {\n    let parent = nodes[name]\n    if (!parent.allowsMarkType(markType)) continue\n    let seen = [], scan = match => {\n      seen.push(match)\n      for (let i = 0; i < match.edgeCount; i++) {\n        let {type, next} = match.edge(i)\n        if (type == nodeType) return true\n        if (seen.indexOf(next) < 0 && scan(next)) return true\n      }\n    }\n    if (scan(parent.contentMatch)) return true\n  }\n}\n\nfunction findSameMarkInSet(mark, set) {\n  for (let i = 0; i < set.length; i++) {\n    if (mark.eq(set[i])) return set[i]\n  }\n}\n","// DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, a `{dom: Node, contentDOM: ?Node}` object, or an array.\n//\n// An array describes a DOM element. The first value in the array\n// should be a string—the name of the DOM element, optionally prefixed\n// by a namespace URL and a space. If the second element is plain\n// object, it is interpreted as a set of attributes for the element.\n// Any elements after that (including the 2nd if it's not an attribute\n// object) are interpreted as children of the DOM elements, and must\n// either be valid `DOMOutputSpec` values, or the number zero.\n//\n// The number zero (pronounced “hole”) is used to indicate the place\n// where a node's child nodes should be inserted. If it occurs in an\n// output spec, it should be the only child element in its parent\n// node.\n\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\nexport class DOMSerializer {\n  // :: (Object<(node: Node) → DOMOutputSpec>, Object<?(mark: Mark, inline: bool) → DOMOutputSpec>)\n  // Create a serializer. `nodes` should map node names to functions\n  // that take a node and return a description of the corresponding\n  // DOM. `marks` does the same for mark names, but also gets an\n  // argument that tells it whether the mark's content is block or\n  // inline content (for typical use, it'll always be inline). A mark\n  // serializer may be `null` to indicate that marks of that type\n  // should not be serialized.\n  constructor(nodes, marks) {\n    // :: Object<(node: Node) → DOMOutputSpec>\n    // The node serialization functions.\n    this.nodes = nodes || {}\n    // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>\n    // The mark serialization functions.\n    this.marks = marks || {}\n  }\n\n  // :: (Fragment, ?Object) → dom.DocumentFragment\n  // Serialize the content of this fragment to a DOM fragment. When\n  // not in the browser, the `document` option, containing a DOM\n  // document, should be passed so that the serializer can create\n  // nodes.\n  serializeFragment(fragment, options = {}, target) {\n    if (!target) target = doc(options).createDocumentFragment()\n\n    let top = target, active = null\n    fragment.forEach(node => {\n      if (active || node.marks.length) {\n        if (!active) active = []\n        let keep = 0, rendered = 0\n        while (keep < active.length && rendered < node.marks.length) {\n          let next = node.marks[rendered]\n          if (!this.marks[next.type.name]) { rendered++; continue }\n          if (!next.eq(active[keep]) || next.type.spec.spanning === false) break\n          keep += 2; rendered++\n        }\n        while (keep < active.length) {\n          top = active.pop()\n          active.pop()\n        }\n        while (rendered < node.marks.length) {\n          let add = node.marks[rendered++]\n          let markDOM = this.serializeMark(add, node.isInline, options)\n          if (markDOM) {\n            active.push(add, top)\n            top.appendChild(markDOM.dom)\n            top = markDOM.contentDOM || markDOM.dom\n          }\n        }\n      }\n      top.appendChild(this.serializeNodeInner(node, options))\n    })\n\n    return target\n  }\n\n  serializeNodeInner(node, options = {}) {\n    let {dom, contentDOM} =\n        DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node))\n    if (contentDOM) {\n      if (node.isLeaf)\n        throw new RangeError(\"Content hole not allowed in a leaf node spec\")\n      if (options.onContent)\n        options.onContent(node, contentDOM, options)\n      else\n        this.serializeFragment(node.content, options, contentDOM)\n    }\n    return dom\n  }\n\n  // :: (Node, ?Object) → dom.Node\n  // Serialize this node to a DOM node. This can be useful when you\n  // need to serialize a part of a document, as opposed to the whole\n  // document. To serialize a whole document, use\n  // [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n  // its [content](#model.Node.content).\n  serializeNode(node, options = {}) {\n    let dom = this.serializeNodeInner(node, options)\n    for (let i = node.marks.length - 1; i >= 0; i--) {\n      let wrap = this.serializeMark(node.marks[i], node.isInline, options)\n      if (wrap) {\n        ;(wrap.contentDOM || wrap.dom).appendChild(dom)\n        dom = wrap.dom\n      }\n    }\n    return dom\n  }\n\n  serializeMark(mark, inline, options = {}) {\n    let toDOM = this.marks[mark.type.name]\n    return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))\n  }\n\n  // :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}\n  // Render an [output spec](#model.DOMOutputSpec) to a DOM node. If\n  // the spec has a hole (zero) in it, `contentDOM` will point at the\n  // node with the hole.\n  static renderSpec(doc, structure, xmlNS = null) {\n    if (typeof structure == \"string\")\n      return {dom: doc.createTextNode(structure)}\n    if (structure.nodeType != null)\n      return {dom: structure}\n    if (structure.dom && structure.dom.nodeType != null)\n      return structure\n    let tagName = structure[0], space = tagName.indexOf(\" \")\n    if (space > 0) {\n      xmlNS = tagName.slice(0, space)\n      tagName = tagName.slice(space + 1)\n    }\n    let contentDOM = null, dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName)\n    let attrs = structure[1], start = 1\n    if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n      start = 2\n      for (let name in attrs) if (attrs[name] != null) {\n        let space = name.indexOf(\" \")\n        if (space > 0) dom.setAttributeNS(name.slice(0, space), name.slice(space + 1), attrs[name])\n        else dom.setAttribute(name, attrs[name])\n      }\n    }\n    for (let i = start; i < structure.length; i++) {\n      let child = structure[i]\n      if (child === 0) {\n        if (i < structure.length - 1 || i > start)\n          throw new RangeError(\"Content hole must be the only child of its parent node\")\n        return {dom, contentDOM: dom}\n      } else {\n        let {dom: inner, contentDOM: innerContent} = DOMSerializer.renderSpec(doc, child, xmlNS)\n        dom.appendChild(inner)\n        if (innerContent) {\n          if (contentDOM) throw new RangeError(\"Multiple content holes\")\n          contentDOM = innerContent\n        }\n      }\n    }\n    return {dom, contentDOM}\n  }\n\n  // :: (Schema) → DOMSerializer\n  // Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n  // properties in a schema's node and mark specs.\n  static fromSchema(schema) {\n    return schema.cached.domSerializer ||\n      (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))\n  }\n\n  // : (Schema) → Object<(node: Node) → DOMOutputSpec>\n  // Gather the serializers in a schema's node specs into an object.\n  // This can be useful as a base to build a custom serializer from.\n  static nodesFromSchema(schema) {\n    let result = gatherToDOM(schema.nodes)\n    if (!result.text) result.text = node => node.text\n    return result\n  }\n\n  // : (Schema) → Object<(mark: Mark) → DOMOutputSpec>\n  // Gather the serializers in a schema's mark specs into an object.\n  static marksFromSchema(schema) {\n    return gatherToDOM(schema.marks)\n  }\n}\n\nfunction gatherToDOM(obj) {\n  let result = {}\n  for (let name in obj) {\n    let toDOM = obj[name].spec.toDOM\n    if (toDOM) result[name] = toDOM\n  }\n  return result\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document\n}\n","// Mappable:: interface\n// There are several things that positions can be mapped through.\n// Such objects conform to this interface.\n//\n//   map:: (pos: number, assoc: ?number) → number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position.\n//\n//   mapResult:: (pos: number, assoc: ?number) → MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping. When content on only one side\n//   is deleted, the position itself is only considered deleted when\n//   `assoc` points in the direction of the deleted content.\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nconst lower16 = 0xffff\nconst factor16 = Math.pow(2, 16)\n\nfunction makeRecover(index, offset) { return index + offset * factor16 }\nfunction recoverIndex(value) { return value & lower16 }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16 }\n\n// ::- An object representing a mapped position with extra\n// information.\nexport class MapResult {\n  constructor(pos, deleted = false, recover = null) {\n    // :: number The mapped version of the position.\n    this.pos = pos\n    // :: bool Tells you whether the position was deleted, that is,\n    // whether the step removed its surroundings from the document.\n    this.deleted = deleted\n    this.recover = recover\n  }\n}\n\n// :: class extends Mappable\n// A map describing the deletions and insertions made by a step, which\n// can be used to find the correspondence between positions in the\n// pre-step version of a document and the same position in the\n// post-step version.\nexport class StepMap {\n  // :: ([number])\n  // Create a position map. The modifications to the document are\n  // represented as an array of numbers, in which each group of three\n  // represents a modified chunk as `[start, oldSize, newSize]`.\n  constructor(ranges, inverted = false) {\n    if (!ranges.length && StepMap.empty) return StepMap.empty\n    this.ranges = ranges\n    this.inverted = inverted\n  }\n\n  recover(value) {\n    let diff = 0, index = recoverIndex(value)\n    if (!this.inverted) for (let i = 0; i < index; i++)\n      diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]\n    return this.ranges[index * 3] + diff + recoverOffset(value)\n  }\n\n  // : (number, ?number) → MapResult\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  // : (number, ?number) → number\n  map(pos, assoc = 1) { return this._map(pos, assoc, true) }\n\n  _map(pos, assoc, simple) {\n    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize\n      if (pos <= end) {\n        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc\n        let result = start + diff + (side < 0 ? 0 : newSize)\n        if (simple) return result\n        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start)\n        return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)\n      }\n      diff += newSize - oldSize\n    }\n    return simple ? pos + diff : new MapResult(pos + diff)\n  }\n\n  touches(pos, recover) {\n    let diff = 0, index = recoverIndex(recover)\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], end = start + oldSize\n      if (pos <= end && i == index * 3) return true\n      diff += this.ranges[i + newIndex] - oldSize\n    }\n    return false\n  }\n\n  // :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n  // Calls the given function on each of the changed ranges included in\n  // this map.\n  forEach(f) {\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff)\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex]\n      f(oldStart, oldStart + oldSize, newStart, newStart + newSize)\n      diff += newSize - oldSize\n    }\n  }\n\n  // :: () → StepMap\n  // Create an inverted version of this map. The result can be used to\n  // map positions in the post-step document to the pre-step document.\n  invert() {\n    return new StepMap(this.ranges, !this.inverted)\n  }\n\n  toString() {\n    return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges)\n  }\n\n  // :: (n: number) → StepMap\n  // Create a map that moves all positions by offset `n` (which may be\n  // negative). This can be useful when applying steps meant for a\n  // sub-document to a larger document, or vice-versa.\n  static offset(n) {\n    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])\n  }\n}\n\n// :: StepMap\n// A StepMap that contains no changed ranges.\nStepMap.empty = new StepMap([])\n\n// :: class extends Mappable\n// A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\n// collaboration or history management.)\nexport class Mapping {\n  // :: (?[StepMap])\n  // Create a new mapping with the given position maps.\n  constructor(maps, mirror, from, to) {\n    // :: [StepMap]\n    // The step maps in this mapping.\n    this.maps = maps || []\n    // :: number\n    // The starting position in the `maps` array, used when `map` or\n    // `mapResult` is called.\n    this.from = from || 0\n    // :: number\n    // The end position in the `maps` array.\n    this.to = to == null ? this.maps.length : to\n    this.mirror = mirror\n  }\n\n  // :: (?number, ?number) → Mapping\n  // Create a mapping that maps only through a part of this one.\n  slice(from = 0, to = this.maps.length) {\n    return new Mapping(this.maps, this.mirror, from, to)\n  }\n\n  copy() {\n    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)\n  }\n\n  // :: (StepMap, ?number)\n  // Add a step map to the end of this mapping. If `mirrors` is\n  // given, it should be the index of the step map that is the mirror\n  // image of this one.\n  appendMap(map, mirrors) {\n    this.to = this.maps.push(map)\n    if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors)\n  }\n\n  // :: (Mapping)\n  // Add all the step maps in a given mapping to this one (preserving\n  // mirroring information).\n  appendMapping(mapping) {\n    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null)\n    }\n  }\n\n  // :: (number) → ?number\n  // Finds the offset of the step map that mirrors the map at the\n  // given offset, in this mapping (as per the second argument to\n  // `appendMap`).\n  getMirror(n) {\n    if (this.mirror) for (let i = 0; i < this.mirror.length; i++)\n      if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)]\n  }\n\n  setMirror(n, m) {\n    if (!this.mirror) this.mirror = []\n    this.mirror.push(n, m)\n  }\n\n  // :: (Mapping)\n  // Append the inverse of the given mapping to this one.\n  appendMappingInverted(mapping) {\n    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null)\n    }\n  }\n\n  // :: () → Mapping\n  // Create an inverted version of this mapping.\n  invert() {\n    let inverse = new Mapping\n    inverse.appendMappingInverted(this)\n    return inverse\n  }\n\n  // : (number, ?number) → number\n  // Map a position through this mapping.\n  map(pos, assoc = 1) {\n    if (this.mirror) return this._map(pos, assoc, true)\n    for (let i = this.from; i < this.to; i++)\n      pos = this.maps[i].map(pos, assoc)\n    return pos\n  }\n\n  // : (number, ?number) → MapResult\n  // Map a position through this mapping, returning a mapping\n  // result.\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  _map(pos, assoc, simple) {\n    let deleted = false\n\n    for (let i = this.from; i < this.to; i++) {\n      let map = this.maps[i], result = map.mapResult(pos, assoc)\n      if (result.recover != null) {\n        let corr = this.getMirror(i)\n        if (corr != null && corr > i && corr < this.to) {\n          i = corr\n          pos = this.maps[corr].recover(result.recover)\n          continue\n        }\n      }\n\n      if (result.deleted) deleted = true\n      pos = result.pos\n    }\n\n    return simple ? pos : new MapResult(pos, deleted)\n  }\n}\n","import {Mapping} from \"./map\"\n\nexport function TransformError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = TransformError.prototype\n  return err\n}\n\nTransformError.prototype = Object.create(Error.prototype)\nTransformError.prototype.constructor = TransformError\nTransformError.prototype.name = \"TransformError\"\n\n// ::- Abstraction to build up and track an array of\n// [steps](#transform.Step) representing a document transformation.\n//\n// Most transforming methods return the `Transform` object itself, so\n// that they can be chained.\nexport class Transform {\n  // :: (Node)\n  // Create a transform that starts with the given document.\n  constructor(doc) {\n    // :: Node\n    // The current document (the result of applying the steps in the\n    // transform).\n    this.doc = doc\n    // :: [Step]\n    // The steps in this transform.\n    this.steps = []\n    // :: [Node]\n    // The documents before each of the steps.\n    this.docs = []\n    // :: Mapping\n    // A mapping with the maps for each of the steps in this transform.\n    this.mapping = new Mapping\n  }\n\n  // :: Node The starting document.\n  get before() { return this.docs.length ? this.docs[0] : this.doc }\n\n  // :: (step: Step) → this\n  // Apply a new step in this transform, saving the result. Throws an\n  // error when the step fails.\n  step(object) {\n    let result = this.maybeStep(object)\n    if (result.failed) throw new TransformError(result.failed)\n    return this\n  }\n\n  // :: (Step) → StepResult\n  // Try to apply a step in this transformation, ignoring it if it\n  // fails. Returns the step result.\n  maybeStep(step) {\n    let result = step.apply(this.doc)\n    if (!result.failed) this.addStep(step, result.doc)\n    return result\n  }\n\n  // :: bool\n  // True when the document has been changed (when there are any\n  // steps).\n  get docChanged() {\n    return this.steps.length > 0\n  }\n\n  addStep(step, doc) {\n    this.docs.push(this.doc)\n    this.steps.push(step)\n    this.mapping.appendMap(step.getMap())\n    this.doc = doc\n  }\n}\n","import {ReplaceError} from \"prosemirror-model\"\n\nimport {StepMap} from \"./map\"\n\nfunction mustOverride() { throw new Error(\"Override me\") }\n\nconst stepsByID = Object.create(null)\n\n// ::- A step object represents an atomic change. It generally applies\n// only to the document it was created for, since the positions\n// stored in it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\nexport class Step {\n  // :: (doc: Node) → StepResult\n  // Applies this step to the given document, returning a result\n  // object that either indicates failure, if the step can not be\n  // applied to this document, or indicates success by containing a\n  // transformed document.\n  apply(_doc) { return mustOverride() }\n\n  // :: () → StepMap\n  // Get the step map that represents the changes made by this step,\n  // and which can be used to transform between positions in the old\n  // and the new document.\n  getMap() { return StepMap.empty }\n\n  // :: (doc: Node) → Step\n  // Create an inverted version of this step. Needs the document as it\n  // was before the step as argument.\n  invert(_doc) { return mustOverride() }\n\n  // :: (mapping: Mappable) → ?Step\n  // Map this step through a mappable thing, returning either a\n  // version of that step with its positions adjusted, or `null` if\n  // the step was entirely deleted by the mapping.\n  map(_mapping) { return mustOverride() }\n\n  // :: (other: Step) → ?Step\n  // Try to merge this step with another one, to be applied directly\n  // after it. Returns the merged step when possible, null if the\n  // steps can't be merged.\n  merge(_other) { return null }\n\n  // :: () → Object\n  // Create a JSON-serializeable representation of this step. When\n  // defining this for a custom subclass, make sure the result object\n  // includes the step type's [JSON id](#transform.Step^jsonID) under\n  // the `stepType` property.\n  toJSON() { return mustOverride() }\n\n  // :: (Schema, Object) → Step\n  // Deserialize a step from its JSON representation. Will call\n  // through to the step class' own implementation of this method.\n  static fromJSON(schema, json) {\n    if (!json || !json.stepType) throw new RangeError(\"Invalid input for Step.fromJSON\")\n    let type = stepsByID[json.stepType]\n    if (!type) throw new RangeError(`No step type ${json.stepType} defined`)\n    return type.fromJSON(schema, json)\n  }\n\n  // :: (string, constructor<Step>)\n  // To be able to serialize steps to JSON, each step needs a string\n  // ID to attach to its JSON representation. Use this method to\n  // register an ID for your step classes. Try to pick something\n  // that's unlikely to clash with steps from other modules.\n  static jsonID(id, stepClass) {\n    if (id in stepsByID) throw new RangeError(\"Duplicate use of step JSON ID \" + id)\n    stepsByID[id] = stepClass\n    stepClass.prototype.jsonID = id\n    return stepClass\n  }\n}\n\n// ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\nexport class StepResult {\n  // : (?Node, ?string)\n  constructor(doc, failed) {\n    // :: ?Node The transformed document.\n    this.doc = doc\n    // :: ?string Text providing information about a failed step.\n    this.failed = failed\n  }\n\n  // :: (Node) → StepResult\n  // Create a successful step result.\n  static ok(doc) { return new StepResult(doc, null) }\n\n  // :: (string) → StepResult\n  // Create a failed step result.\n  static fail(message) { return new StepResult(null, message) }\n\n  // :: (Node, number, number, Slice) → StepResult\n  // Call [`Node.replace`](#model.Node.replace) with the given\n  // arguments. Create a successful result if it succeeds, and a\n  // failed one if it throws a `ReplaceError`.\n  static fromReplace(doc, from, to, slice) {\n    try {\n      return StepResult.ok(doc.replace(from, to, slice))\n    } catch (e) {\n      if (e instanceof ReplaceError) return StepResult.fail(e.message)\n      throw e\n    }\n  }\n}\n","import {Slice} from \"prosemirror-model\"\n\nimport {Step, StepResult} from \"./step\"\nimport {StepMap} from \"./map\"\n\n// ::- Replace a part of the document with a slice of new content.\nexport class ReplaceStep extends Step {\n  // :: (number, number, Slice, ?bool)\n  // The given `slice` should fit the 'gap' between `from` and\n  // `to`—the depths must line up, and the surrounding nodes must be\n  // able to be joined with the open sides of the slice. When\n  // `structure` is true, the step will fail if the content between\n  // from and to is not just a sequence of closing and then opening\n  // tokens (this is to guard against rebased replace steps\n  // overwriting something they weren't supposed to).\n  constructor(from, to, slice, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to))\n      return StepResult.fail(\"Structure replace would overwrite content\")\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.to - this.from, this.slice.size])\n  }\n\n  invert(doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted) return null\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)\n  }\n\n  merge(other) {\n    if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null\n\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd)\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd)\n      return new ReplaceStep(other.from, this.to, slice, this.structure)\n    } else {\n      return null\n    }\n  }\n\n  toJSON() {\n    let json = {stepType: \"replace\", from: this.from, to: this.to}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\")\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)\n  }\n}\n\nStep.jsonID(\"replace\", ReplaceStep)\n\n// ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\nexport class ReplaceAroundStep extends Step {\n  // :: (number, number, number, number, Slice, number, ?bool)\n  // Create a replace-around step with the given range and gap.\n  // `insert` should be the point in the slice into which the content\n  // of the gap should be moved. `structure` has the same meaning as\n  // it has in the [`ReplaceStep`](#transform.ReplaceStep) class.\n  constructor(from, to, gapFrom, gapTo, slice, insert, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: number\n    // The start of preserved range.\n    this.gapFrom = gapFrom\n    // :: number\n    // The end of preserved range.\n    this.gapTo = gapTo\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    // :: number\n    // The position in the slice where the preserved range should be\n    // inserted.\n    this.insert = insert\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n                           contentBetween(doc, this.gapTo, this.to)))\n      return StepResult.fail(\"Structure gap-replace would overwrite content\")\n\n    let gap = doc.slice(this.gapFrom, this.gapTo)\n    if (gap.openStart || gap.openEnd)\n      return StepResult.fail(\"Gap is not a flat range\")\n    let inserted = this.slice.insertAt(this.insert, gap.content)\n    if (!inserted) return StepResult.fail(\"Content does not fit in gap\")\n    return StepResult.fromReplace(doc, this.from, this.to, inserted)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])\n  }\n\n  invert(doc) {\n    let gap = this.gapTo - this.gapFrom\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,\n                                 this.from + this.insert, this.from + this.insert + gap,\n                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),\n                                 this.gapFrom - this.from, this.structure)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1)\n    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) return null\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)\n  }\n\n  toJSON() {\n    let json = {stepType: \"replaceAround\", from: this.from, to: this.to,\n                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n        typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\")\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,\n                                 Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)\n  }\n}\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep)\n\nfunction contentBetween(doc, from, to) {\n  let $from = doc.resolve(from), dist = to - from, depth = $from.depth\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--\n    dist--\n  }\n  if (dist > 0) {\n    let next = $from.node(depth).maybeChild($from.indexAfter(depth))\n    while (dist > 0) {\n      if (!next || next.isLeaf) return true\n      next = next.firstChild\n      dist--\n    }\n  }\n  return false\n}\n","import {Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) &&\n    (end == node.childCount || node.canReplace(0, end))\n}\n\n// :: (NodeRange) → ?number\n// Try to find a target depth to which the content in the given range\n// can be lifted. Will not go across\n// [isolating](#model.NodeSpec.isolating) parent nodes.\nexport function liftTarget(range) {\n  let parent = range.parent\n  let content = parent.content.cutByIndex(range.startIndex, range.endIndex)\n  for (let depth = range.depth;; --depth) {\n    let node = range.$from.node(depth)\n    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth)\n    if (depth < range.depth && node.canReplace(index, endIndex, content))\n      return depth\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break\n  }\n}\n\n// :: (NodeRange, number) → this\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// [`liftTarget`](#transform.liftTarget) to compute `target`, to make\n// sure the lift is valid.\nTransform.prototype.lift = function(range, target) {\n  let {$from, $to, depth} = range\n\n  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1)\n  let start = gapStart, end = gapEnd\n\n  let before = Fragment.empty, openStart = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $from.index(d) > 0) {\n      splitting = true\n      before = Fragment.from($from.node(d).copy(before))\n      openStart++\n    } else {\n      start--\n    }\n  let after = Fragment.empty, openEnd = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $to.after(d + 1) < $to.end(d)) {\n      splitting = true\n      after = Fragment.from($to.node(d).copy(after))\n      openEnd++\n    } else {\n      end++\n    }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,\n                                         new Slice(before.append(after), openStart, openEnd),\n                                         before.size - openStart, true))\n}\n\n// :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]\n// Try to find a valid way to wrap the content in the given range in a\n// node of the given type. May introduce extra nodes around and inside\n// the wrapper node, if necessary. Returns null if no valid wrapping\n// could be found. When `innerRange` is given, that range's content is\n// used as the content to fit into the wrapping, instead of the\n// content of `range`.\nexport function findWrapping(range, nodeType, attrs, innerRange = range) {\n  let around = findWrappingOutside(range, nodeType)\n  let inner = around && findWrappingInside(innerRange, nodeType)\n  if (!inner) return null\n  return around.map(withAttrs).concat({type: nodeType, attrs}).concat(inner.map(withAttrs))\n}\n\nfunction withAttrs(type) { return {type, attrs: null} }\n\nfunction findWrappingOutside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let around = parent.contentMatchAt(startIndex).findWrapping(type)\n  if (!around) return null\n  let outer = around.length ? around[0] : type\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null\n}\n\nfunction findWrappingInside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let inner = parent.child(startIndex)\n  let inside = type.contentMatch.findWrapping(inner.type)\n  if (!inside) return null\n  let lastType = inside.length ? inside[inside.length - 1] : type\n  let innerMatch = lastType.contentMatch\n  for (let i = startIndex; innerMatch && i < endIndex; i++)\n    innerMatch = innerMatch.matchType(parent.child(i).type)\n  if (!innerMatch || !innerMatch.validEnd) return null\n  return inside\n}\n\n// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with [`findWrapping`](#transform.findWrapping).\nTransform.prototype.wrap = function(range, wrappers) {\n  let content = Fragment.empty\n  for (let i = wrappers.length - 1; i >= 0; i--) {\n    if (content.size) {\n      let match = wrappers[i].type.contentMatch.matchFragment(content)\n      if (!match || !match.validEnd)\n        throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\")\n    }\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content))\n  }\n\n  let start = range.start, end = range.end\n  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))\n}\n\n// :: (number, ?number, NodeType, ?Object) → this\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\nTransform.prototype.setBlockType = function(from, to = from, type, attrs) {\n  if (!type.isTextblock) throw new RangeError(\"Type given to setBlockType should be a textblock\")\n  let mapFrom = this.steps.length\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this.doc, this.mapping.slice(mapFrom).map(pos), type)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this.clearIncompatible(this.mapping.slice(mapFrom).map(pos, 1), type)\n      let mapping = this.mapping.slice(mapFrom)\n      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1)\n      this.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,\n                                      new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true))\n      return false\n    }\n  })\n  return this\n}\n\nfunction canChangeType(doc, pos, type) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return $pos.parent.canReplaceWith(index, index + 1, type)\n}\n\n// :: (number, ?NodeType, ?Object, ?[Mark]) → this\n// Change the type, attributes, and/or marks of the node at `pos`.\n// When `type` isn't given, the existing node type is preserved,\nTransform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {\n  let node = this.doc.nodeAt(pos)\n  if (!node) throw new RangeError(\"No node at given position\")\n  if (!type) type = node.type\n  let newNode = type.create(attrs, null, marks || node.marks)\n  if (node.isLeaf)\n    return this.replaceWith(pos, pos + node.nodeSize, newNode)\n\n  if (!type.validContent(node.content))\n    throw new RangeError(\"Invalid content for node type \" + type.name)\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,\n                                         new Slice(Fragment.from(newNode), 0, 0), 1, true))\n}\n\n// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool\n// Check whether splitting at the given position is allowed.\nexport function canSplit(doc, pos, depth = 1, typesAfter) {\n  let $pos = doc.resolve(pos), base = $pos.depth - depth\n  let innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent\n  if (base < 0 || $pos.parent.type.spec.isolating ||\n      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n    return false\n  for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    let node = $pos.node(d), index = $pos.index(d)\n    if (node.type.spec.isolating) return false\n    let rest = node.content.cutByIndex(index, node.childCount)\n    let after = (typesAfter && typesAfter[i]) || node\n    if (after != node) rest = rest.replaceChild(0, after.type.create(after.attrs))\n    if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n      return false\n  }\n  let index = $pos.indexAfter(base)\n  let baseType = typesAfter && typesAfter[0]\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)\n}\n\n// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\nTransform.prototype.split = function(pos, depth = 1, typesAfter) {\n  let $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty\n  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before))\n    let typeAfter = typesAfter && typesAfter[i]\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after))\n  }\n  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true))\n}\n\n// :: (Node, number) → bool\n// Test whether the blocks before and after a given position can be\n// joined.\nexport function canJoin(doc, pos) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n    $pos.parent.canReplace(index, index + 1)\n}\n\nfunction joinable(a, b) {\n  return a && b && !a.isLeaf && a.canAppend(b)\n}\n\n// :: (Node, number, ?number) → ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\nexport function joinPoint(doc, pos, dir = -1) {\n  let $pos = doc.resolve(pos)\n  for (let d = $pos.depth;; d--) {\n    let before, after, index = $pos.index(d)\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore\n      after = $pos.nodeAfter\n    } else if (dir > 0) {\n      before = $pos.node(d + 1)\n      index++\n      after = $pos.node(d).maybeChild(index)\n    } else {\n      before = $pos.node(d).maybeChild(index - 1)\n      after = $pos.node(d + 1)\n    }\n    if (before && !before.isTextblock && joinable(before, after) &&\n        $pos.node(d).canReplace(index, index + 1)) return pos\n    if (d == 0) break\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d)\n  }\n}\n\n// :: (number, ?number) → this\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\nTransform.prototype.join = function(pos, depth = 1) {\n  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true)\n  return this.step(step)\n}\n\n// :: (Node, number, NodeType) → ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\nexport function insertPoint(doc, pos, nodeType) {\n  let $pos = doc.resolve(pos)\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos\n\n  if ($pos.parentOffset == 0)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.index(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1)\n      if (index > 0) return null\n    }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.indexAfter(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.after(d + 1)\n      if (index < $pos.node(d).childCount) return null\n    }\n}\n\n// :: (Node, number, Slice) → ?number\n// Finds a position at or around the given position where the given\n// slice can be inserted. Will look at parent nodes' nearest boundary\n// and try there, even if the original position wasn't directly at the\n// start or end of that node. Returns null when no position was found.\nexport function dropPoint(doc, pos, slice) {\n  let $pos = doc.resolve(pos)\n  if (!slice.content.size) return pos\n  let content = slice.content\n  for (let i = 0; i < slice.openStart; i++) content = content.firstChild.content\n  for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (let d = $pos.depth; d >= 0; d--) {\n      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1\n      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0)\n      let parent = $pos.node(d), fits = false\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content)\n      } else {\n        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type)\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0])\n      }\n      if (fits)\n        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1)\n    }\n  }\n  return null\n}\n","import {Fragment, Slice} from \"prosemirror-model\"\nimport {Step, StepResult} from \"./step\"\n\nfunction mapFragment(fragment, f, parent) {\n  let mapped = []\n  for (let i = 0; i < fragment.childCount; i++) {\n    let child = fragment.child(i)\n    if (child.content.size) child = child.copy(mapFragment(child.content, f, child))\n    if (child.isInline) child = f(child, parent, i)\n    mapped.push(child)\n  }\n  return Fragment.fromArray(mapped)\n}\n\n// ::- Add a mark to all inline content between two positions.\nexport class AddMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the marked range.\n    this.from = from\n    // :: number\n    // The end of the marked range.\n    this.to = to\n    // :: Mark\n    // The mark to add.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from)\n    let parent = $from.node($from.sharedDepth(this.to))\n    let slice = new Slice(mapFragment(oldSlice.content, (node, parent) => {\n      if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type)) return node\n      return node.mark(this.mark.addToSet(node.marks))\n    }, parent), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new RemoveMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new AddMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof AddMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new AddMarkStep(Math.min(this.from, other.from),\n                             Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\")\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"addMark\", AddMarkStep)\n\n// ::- Remove a mark from all inline content between two positions.\nexport class RemoveMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the unmarked range.\n    this.from = from\n    // :: number\n    // The end of the unmarked range.\n    this.to = to\n    // :: Mark\n    // The mark to remove.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to)\n    let slice = new Slice(mapFragment(oldSlice.content, node => {\n      return node.mark(this.mark.removeFromSet(node.marks))\n    }), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new AddMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new RemoveMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof RemoveMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new RemoveMarkStep(Math.min(this.from, other.from),\n                                Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\")\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"removeMark\", RemoveMarkStep)\n","import {MarkType, Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {AddMarkStep, RemoveMarkStep} from \"./mark_step\"\nimport {ReplaceStep} from \"./replace_step\"\n\n// :: (number, number, Mark) → this\n// Add the given mark to the inline content between `from` and `to`.\nTransform.prototype.addMark = function(from, to, mark) {\n  let removed = [], added = [], removing = null, adding = null\n  this.doc.nodesBetween(from, to, (node, pos, parent) => {\n    if (!node.isInline) return\n    let marks = node.marks\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to)\n      let newSet = mark.addToSet(marks)\n\n      for (let i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i]))\n            removing.to = end\n          else\n            removed.push(removing = new RemoveMarkStep(start, end, marks[i]))\n        }\n      }\n\n      if (adding && adding.to == start)\n        adding.to = end\n      else\n        added.push(adding = new AddMarkStep(start, end, mark))\n    }\n  })\n\n  removed.forEach(s => this.step(s))\n  added.forEach(s => this.step(s))\n  return this\n}\n\n// :: (number, number, ?union<Mark, MarkType>) → this\n// Remove marks from inline nodes between `from` and `to`. When `mark`\n// is a single mark, remove precisely that mark. When it is a mark type,\n// remove all marks of that type. When it is null, remove all marks of\n// any type.\nTransform.prototype.removeMark = function(from, to, mark = null) {\n  let matched = [], step = 0\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isInline) return\n    step++\n    let toRemove = null\n    if (mark instanceof MarkType) {\n      let set = node.marks, found\n      while (found = mark.isInSet(set)) {\n        ;(toRemove || (toRemove = [])).push(found)\n        set = found.removeFromSet(set)\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) toRemove = [mark]\n    } else {\n      toRemove = node.marks\n    }\n    if (toRemove && toRemove.length) {\n      let end = Math.min(pos + node.nodeSize, to)\n      for (let i = 0; i < toRemove.length; i++) {\n        let style = toRemove[i], found\n        for (let j = 0; j < matched.length; j++) {\n          let m = matched[j]\n          if (m.step == step - 1 && style.eq(matched[j].style)) found = m\n        }\n        if (found) {\n          found.to = end\n          found.step = step\n        } else {\n          matched.push({style, from: Math.max(pos, from), to: end, step})\n        }\n      }\n    }\n  })\n  matched.forEach(m => this.step(new RemoveMarkStep(m.from, m.to, m.style)))\n  return this\n}\n\n// :: (number, NodeType, ?ContentMatch) → this\n// Removes all marks and nodes from the content of the node at `pos`\n// that don't match the given new parent node type. Accepts an\n// optional starting [content match](#model.ContentMatch) as third\n// argument.\nTransform.prototype.clearIncompatible = function(pos, parentType, match = parentType.contentMatch) {\n  let node = this.doc.nodeAt(pos)\n  let delSteps = [], cur = pos + 1\n  for (let i = 0; i < node.childCount; i++) {\n    let child = node.child(i), end = cur + child.nodeSize\n    let allowed = match.matchType(child.type, child.attrs)\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, Slice.empty))\n    } else {\n      match = allowed\n      for (let j = 0; j < child.marks.length; j++) if (!parentType.allowsMarkType(child.marks[j].type))\n        this.step(new RemoveMarkStep(cur, end, child.marks[j]))\n    }\n    cur = end\n  }\n  if (!match.validEnd) {\n    let fill = match.fillBefore(Fragment.empty, true)\n    this.replace(cur, cur, new Slice(fill, 0, 0))\n  }\n  for (let i = delSteps.length - 1; i >= 0; i--) this.step(delSteps[i])\n  return this\n}\n","import {Fragment, Slice} from \"prosemirror-model\"\n\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\nimport {Transform} from \"./transform\"\nimport {insertPoint} from \"./structure\"\n\n// :: (Node, number, ?number, ?Slice) → ?Step\n// ‘Fit’ a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it. Will return null if\n// there's no meaningful way to insert the slice here, or inserting it\n// would be a no-op (an empty slice over an empty range).\nexport function replaceStep(doc, from, to = from, slice = Slice.empty) {\n  if (from == to && !slice.size) return null\n\n  let $from = doc.resolve(from), $to = doc.resolve(to)\n  // Optimization -- avoid work if it's obvious that it's not needed.\n  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice)\n  return new Fitter($from, $to, slice).fit()\n}\n\n// :: (number, ?number, ?Slice) → this\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\nTransform.prototype.replace = function(from, to = from, slice = Slice.empty) {\n  let step = replaceStep(this.doc, from, to, slice)\n  if (step) this.step(step)\n  return this\n}\n\n// :: (number, number, union<Fragment, Node, [Node]>) → this\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\nTransform.prototype.replaceWith = function(from, to, content) {\n  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))\n}\n\n// :: (number, number) → this\n// Delete the content between the given positions.\nTransform.prototype.delete = function(from, to) {\n  return this.replace(from, to, Slice.empty)\n}\n\n// :: (number, union<Fragment, Node, [Node]>) → this\n// Insert the given content at the given position.\nTransform.prototype.insert = function(pos, content) {\n  return this.replaceWith(pos, pos, content)\n}\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n    $from.parent.canReplace($from.index(), $to.index(), slice.content)\n}\n\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n  constructor($from, $to, slice) {\n    this.$to = $to\n    this.$from = $from\n    this.unplaced = slice\n\n    this.frontier = []\n    for (let i = 0; i <= $from.depth; i++) {\n      let node = $from.node(i)\n      this.frontier.push({\n        type: node.type,\n        match: node.contentMatchAt($from.indexAfter(i))\n      })\n    }\n\n    this.placed = Fragment.empty\n    for (let i = $from.depth; i > 0; i--)\n      this.placed = Fragment.from($from.node(i).copy(this.placed))\n  }\n\n  get depth() { return this.frontier.length - 1 }\n\n  fit() {\n    // As long as there's unplaced content, try to place some of it.\n    // If that fails, either increase the open score of the unplaced\n    // slice, or drop nodes from it, and then try again.\n    while (this.unplaced.size) {\n      let fit = this.findFittable()\n      if (fit) this.placeNodes(fit)\n      else this.openMore() || this.dropNode()\n    }\n    // When there's inline content directly after the frontier _and_\n    // directly after `this.$to`, we must generate a `ReplaceAround`\n    // step that pulls that content into the node after the frontier.\n    // That means the fitting must be done to the end of the textblock\n    // node after `this.$to`, not `this.$to` itself.\n    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth\n    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline))\n    if (!$to) return null\n\n    // If closing to `$to` succeeded, create a step\n    let content = this.placed, openStart = $from.depth, openEnd = $to.depth\n    while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n      content = content.firstChild.content\n      openStart--; openEnd--\n    }\n    let slice = new Slice(content, openStart, openEnd)\n    if (moveInline > -1)\n      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize)\n    if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n      return new ReplaceStep($from.pos, $to.pos, slice)\n  }\n\n  // Find a position on the start spine of `this.unplaced` that has\n  // content that can be moved somewhere on the frontier. Returns two\n  // depths, one for the slice and one for the frontier.\n  findFittable() {\n    // Only try wrapping nodes (pass 2) after finding a place without\n    // wrapping failed.\n    for (let pass = 1; pass <= 2; pass++) {\n      for (let sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n        let fragment, parent\n        if (sliceDepth) {\n          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild\n          fragment = parent.content\n        } else {\n          fragment = this.unplaced.content\n        }\n        let first = fragment.firstChild\n        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n          let {type, match} = this.frontier[frontierDepth], wrap, inject\n          // In pass 1, if the next node matches, or there is no next\n          // node but the parents look compatible, we've found a\n          // place.\n          if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))\n                            : type.compatibleContent(parent.type)))\n            return {sliceDepth, frontierDepth, parent, inject}\n          // In pass 2, look for a set of wrapping nodes that make\n          // `first` fit here.\n          else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n            return {sliceDepth, frontierDepth, parent, wrap}\n          // Don't continue looking further up if the parent node\n          // would fit here.\n          if (parent && match.matchType(parent.type)) break\n        }\n      }\n    }\n  }\n\n  openMore() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (!inner.childCount || inner.firstChild.isLeaf) return false\n    this.unplaced = new Slice(content, openStart + 1,\n                              Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0))\n    return true\n  }\n\n  dropNode() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (inner.childCount <= 1 && openStart > 0) {\n      let openAtEnd = content.size - openStart <= openStart + inner.size\n      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,\n                                openAtEnd ? openStart - 1 : openEnd)\n    } else {\n      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd)\n    }\n  }\n\n  // : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})\n  // Move content from the unplaced slice at `sliceDepth` to the\n  // frontier node at `frontierDepth`. Close that frontier node when\n  // applicable.\n  placeNodes({sliceDepth, frontierDepth, parent, inject, wrap}) {\n    while (this.depth > frontierDepth) this.closeFrontierNode()\n    if (wrap) for (let i = 0; i < wrap.length; i++) this.openFrontierNode(wrap[i])\n\n    let slice = this.unplaced, fragment = parent ? parent.content : slice.content\n    let openStart = slice.openStart - sliceDepth\n    let taken = 0, add = []\n    let {match, type} = this.frontier[frontierDepth]\n    if (inject) {\n      for (let i = 0; i < inject.childCount; i++) add.push(inject.child(i))\n      match = match.matchFragment(inject)\n    }\n    // Computes the amount of (end) open nodes at the end of the\n    // fragment. When 0, the parent is open, but no more. When\n    // negative, nothing is open.\n    let openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd)\n    // Scan over the fragment, fitting as many child nodes as\n    // possible.\n    while (taken < fragment.childCount) {\n      let next = fragment.child(taken), matches = match.matchType(next.type)\n      if (!matches) break\n      taken++\n      if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n        match = matches\n        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,\n                                taken == fragment.childCount ? openEndCount : -1))\n      }\n    }\n    let toEnd = taken == fragment.childCount\n    if (!toEnd) openEndCount = -1\n\n    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add))\n    this.frontier[frontierDepth].match = match\n\n    // If the parent types match, and the entire node was moved, and\n    // it's not open, close this frontier node right away.\n    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n      this.closeFrontierNode()\n\n    // Add new frontier nodes for any open nodes at the end.\n    for (let i = 0, cur = fragment; i < openEndCount; i++) {\n      let node = cur.lastChild\n      this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)})\n      cur = node.content\n    }\n\n    // Update `this.unplaced`. Drop the entire node from which we\n    // placed it we got to its end, otherwise just drop the placed\n    // nodes.\n    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n      : sliceDepth == 0 ? Slice.empty\n      : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),\n                  sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1)\n  }\n\n  mustMoveInline() {\n    if (!this.$to.parent.isTextblock) return -1\n    let top = this.frontier[this.depth], level\n    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n        (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) return -1\n\n    let {depth} = this.$to, after = this.$to.after(depth)\n    while (depth > 1 && after == this.$to.end(--depth)) ++after\n    return after\n  }\n\n  findCloseLevel($to) {\n    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n      let {match, type} = this.frontier[i]\n      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1))\n      let fit = contentAfterFits($to, i, type, match, dropInner)\n      if (!fit) continue\n      for (let d = i - 1; d >= 0; d--) {\n        let {match, type} = this.frontier[d]\n        let matches = contentAfterFits($to, d, type, match, true)\n        if (!matches || matches.childCount) continue scan\n      }\n      return {depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to}\n    }\n  }\n\n  close($to) {\n    let close = this.findCloseLevel($to)\n    if (!close) return null\n\n    while (this.depth > close.depth) this.closeFrontierNode()\n    if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit)\n    $to = close.move\n    for (let d = close.depth + 1; d <= $to.depth; d++) {\n      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d))\n      this.openFrontierNode(node.type, node.attrs, add)\n    }\n    return $to\n  }\n\n  openFrontierNode(type, attrs, content) {\n    let top = this.frontier[this.depth]\n    top.match = top.match.matchType(type)\n    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)))\n    this.frontier.push({type, match: type.contentMatch})\n  }\n\n  closeFrontierNode() {\n    let open = this.frontier.pop()\n    let add = open.match.fillBefore(Fragment.empty, true)\n    if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add)\n  }\n}\n\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) return fragment.cutByIndex(count)\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))\n}\n\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) return fragment.append(content)\n  return fragment.replaceChild(fragment.childCount - 1,\n                               fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))\n}\n\nfunction contentAt(fragment, depth) {\n  for (let i = 0; i < depth; i++) fragment = fragment.firstChild.content\n  return fragment\n}\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) return node\n  let frag = node.content\n  if (openStart > 1)\n    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0))\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag)\n    if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true))\n  }\n  return node.copy(frag)\n}\n\nfunction contentAfterFits($to, depth, type, match, open) {\n  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth)\n  if (index == node.childCount && !type.compatibleContent(node.type)) return null\n  let fit = match.fillBefore(node.content, true, index)\n  return fit && !invalidMarks(type, node.content, index) ? fit : null\n}\n\nfunction invalidMarks(type, fragment, start) {\n  for (let i = start; i < fragment.childCount; i++)\n    if (!type.allowsMarks(fragment.child(i).marks)) return true\n  return false\n}\n\nfunction definesContent(type) {\n  return type.spec.defining || type.spec.definingForContent\n}\n\n// :: (number, number, Slice) → this\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openStart`](#model.Slice.openStart) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining as context](#model.NodeSpec.definingAsContext), or\n// including an open parent node from the slice that _is_ marked as\n// [defining its content](#model.NodeSpec.definingForContent).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\nTransform.prototype.replaceRange = function(from, to, slice) {\n  if (!slice.size) return this.deleteRange(from, to)\n\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  if (fitsTrivially($from, $to, slice))\n    return this.step(new ReplaceStep(from, to, slice))\n\n  let targetDepths = coveredDepths($from, this.doc.resolve(to))\n  // Can't replace the whole document, so remove 0 if it's present\n  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop()\n  // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n  let preferredTarget = -($from.depth + 1)\n  targetDepths.unshift(preferredTarget)\n  // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    let spec = $from.node(d).type.spec\n    if (spec.defining || spec.definingAsContext || spec.isolating) break\n    if (targetDepths.indexOf(d) > -1) preferredTarget = d\n    else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d)\n  }\n  // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n  let preferredTargetIndex = targetDepths.indexOf(preferredTarget)\n\n  let leftNodes = [], preferredDepth = slice.openStart\n  for (let content = slice.content, i = 0;; i++) {\n    let node = content.firstChild\n    leftNodes.push(node)\n    if (i == slice.openStart) break\n    content = node.content\n  }\n\n  // Back up preferredDepth to cover defining textblocks directly\n  // above it, possibly skipping a non-defining textblock.\n  for (let d = preferredDepth - 1; d >= 0; d--) {\n    let type = leftNodes[d].type, def = definesContent(type)\n    if (def && $from.node(preferredTargetIndex).type != type) preferredDepth = d\n    else if (def || !type.isTextblock) break\n  }\n\n  for (let j = slice.openStart; j >= 0; j--) {\n    let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1)\n    let insert = leftNodes[openDepth]\n    if (!insert) continue\n    for (let i = 0; i < targetDepths.length; i++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true\n      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth }\n      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1)\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n        return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,\n                            new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),\n                                      openDepth, slice.openEnd))\n    }\n  }\n\n  let startSteps = this.steps.length\n  for (let i = targetDepths.length - 1; i >= 0; i--) {\n    this.replace(from, to, slice)\n    if (this.steps.length > startSteps) break\n    let depth = targetDepths[i]\n    if (depth < 0) continue\n    from = $from.before(depth); to = $to.after(depth)\n  }\n  return this\n}\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    let first = fragment.firstChild\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)))\n  }\n  if (depth > newOpen) {\n    let match = parent.contentMatchAt(0)\n    let start = match.fillBefore(fragment).append(fragment)\n    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true))\n  }\n  return fragment\n}\n\n// :: (number, number, Node) → this\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\nTransform.prototype.replaceRangeWith = function(from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    let point = insertPoint(this.doc, from, node.type)\n    if (point != null) from = to = point\n  }\n  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))\n}\n\n// :: (number, number) → this\n// Delete the given range, expanding it to cover fully covered\n// parent nodes until a valid replace is found.\nTransform.prototype.deleteRange = function(from, to) {\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  let covered = coveredDepths($from, $to)\n  for (let i = 0; i < covered.length; i++) {\n    let depth = covered[i], last = i == covered.length - 1\n    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n      return this.delete($from.start(depth), $to.end(depth))\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n      return this.delete($from.before(depth), $to.after(depth))\n  }\n  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n      return this.delete($from.before(d), to)\n  }\n  return this.delete(from, to)\n}\n\n// : (ResolvedPos, ResolvedPos) → [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n  let result = [], minDepth = Math.min($from.depth, $to.depth)\n  for (let d = minDepth; d >= 0; d--) {\n    let start = $from.start(d)\n    if (start < $from.pos - ($from.depth - d) ||\n        $to.end(d) > $to.pos + ($to.depth - d) ||\n        $from.node(d).type.spec.isolating ||\n        $to.node(d).type.spec.isolating) break\n    if (start == $to.start(d) ||\n        (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&\n         d && $to.start(d - 1) == start - 1))\n      result.push(d)\n  }\n  return result\n}\n","import type { RichEditorContent } from \"../../rich-editor\";\nimport type { JSONContent } from \"@tiptap/core\";\n\nexport function createDocument(content: JSONContent[]): RichEditorContent {\n  return {\n    type: \"doc\",\n    content,\n  };\n}\n\nexport function createMention(variableId: string) {\n  return {\n    type: \"mention\",\n    attrs: {\n      variable: {\n        id: variableId,\n      },\n    },\n  };\n}\n\nexport function createParagraph(content: JSONContent[]) {\n  return {\n    type: \"paragraph\",\n    content,\n  };\n}\n\nexport function createDocumentWithMention(variableId: string) {\n  return createDocument([createParagraph([createMention(variableId)])]);\n}\n\nexport function plainToRichText(plainText: string): RichEditorContent {\n  const content = plainText === \"\" ? undefined : [toTextNode(plainText)];\n\n  return createDocument([\n    {\n      type: \"paragraph\",\n      ...(content ? { content } : undefined),\n    },\n  ]);\n}\n\nexport function toTextNode(plainText: string): JSONContent {\n  return {\n    type: \"text\",\n    text: plainText,\n  };\n}\n","import { JSONContent } from \"@tiptap/core\";\nimport { Transform } from \"prosemirror-transform\";\n\nimport { schema } from \"../schema\";\nimport { plainToRichText } from \"./plainToRichText\";\n\nexport function appendText(\n  original: JSONContent,\n  stringToAppend: string\n): JSONContent {\n  if (original == null) {\n    return plainToRichText(stringToAppend);\n  }\n\n  const originalContent = schema.nodeFromJSON(original);\n  const contentToAppend = schema.text(stringToAppend);\n  const paragraph = originalContent.firstChild!;\n\n  const tr = new Transform(paragraph).insert(\n    paragraph.content.size,\n    contentToAppend\n  );\n  return tr.doc.toJSON();\n}\n","import { JSONContent } from \"@tiptap/core\";\n\nexport function flatMapMentions(\n  contentUnresolved: JSONContent,\n  cb: (node: JSONContent) => JSONContent[]\n): JSONContent {\n  if (contentUnresolved.type === \"mention\") {\n    return cb(contentUnresolved);\n  }\n\n  if (contentUnresolved.content != null) {\n    return {\n      ...contentUnresolved,\n      content: contentUnresolved.content.flatMap((c) => flatMapMentions(c, cb)),\n    };\n  }\n\n  return contentUnresolved;\n}\n","import { JSONContent } from \"@tiptap/core\";\nimport { Transform } from \"prosemirror-transform\";\n\nimport { schema } from \"../schema\";\n\nexport function prependText(\n  original: JSONContent,\n  stringToAppend: string\n): JSONContent {\n  const originalContent = schema.nodeFromJSON(original);\n  const contentToAppend = schema.text(stringToAppend);\n  const paragraph = originalContent.firstChild!;\n\n  const tr = new Transform(paragraph).insert(0, contentToAppend);\n  return tr.doc.toJSON();\n}\n","import { JSONContent } from \"@tiptap/core\";\n\nimport { Variable } from \"../extensions/mention\";\nimport { flatMapMentions } from \"./mapMentions\";\n\nexport function resolveMentions(\n  contentResolved: JSONContent,\n  variables: readonly Variable[]\n) {\n  if (contentResolved == null) {\n    return null;\n  }\n\n  return flatMapMentions(contentResolved, (mention) => {\n    const variableId = mention.attrs!.variable.id;\n    const variable = variables.find((v) => v.id === variableId);\n\n    return [\n      {\n        ...mention,\n        attrs: {\n          variable,\n        },\n      },\n    ];\n  });\n}\n","import { getText, JSONContent, TextSerializer } from \"@tiptap/core\";\nimport { Schema } from \"prosemirror-model\";\n\nimport { schema } from \"../schema\";\n\nexport function richTextToPlain(\n  contentResolved: JSONContent,\n  fallbackEmptyToLabel = false\n): string {\n  const blockSeparator = \"\\n\\n\";\n  const contentNode = schema.nodeFromJSON(contentResolved);\n  const textSerializers = getTextSeralizersFromSchema(schema);\n\n  if (fallbackEmptyToLabel) {\n    return getText(contentNode, {\n      blockSeparator,\n      textSerializers,\n    });\n  }\n\n  return getText(contentNode, {\n    blockSeparator,\n    textSerializers: {\n      ...textSerializers,\n      mention: (props) => {\n        if (props.node.attrs.value == null) {\n          return \"\";\n        }\n        return textSerializers.mention(props);\n      },\n    },\n  });\n}\n\n// https://github.com/ueberdosis/tiptap/blob/main/packages/core/src/helpers/getTextSeralizersFromSchema.ts\nexport function getTextSeralizersFromSchema(\n  s: Schema\n): Record<string, TextSerializer> {\n  return Object.fromEntries(\n    Object.entries(s.nodes)\n      .filter(([, node]) => node.spec.toText)\n      .map(([name, node]) => [name, node.spec.toText])\n  );\n}\n","import { JSONContent } from \"@tiptap/core\";\nimport { generateHTML } from \"@tiptap/html\";\n\nimport { SCHEMA_EXTENSIONS } from \"../schema\";\n\nexport function toHTML(resolvedContent: JSONContent): string {\n  return generateHTML(resolvedContent, SCHEMA_EXTENSIONS as any);\n}\n","import { JSONContent } from \"@tiptap/core\";\n\nimport { flatMapMentions } from \"./mapMentions\";\n\nexport function unresolveMentions(contentResolved: JSONContent) {\n  if (contentResolved == null) {\n    return null;\n  }\n\n  return flatMapMentions(contentResolved, (mention) => {\n    return [\n      {\n        ...mention,\n        attrs: {\n          variable: {\n            id: mention.attrs!.variable.id,\n          },\n        },\n      },\n    ];\n  });\n}\n","import {\n  createDocument,\n  createMention,\n  createParagraph,\n  toTextNode,\n} from \"./plainToRichText\";\n\nexport function curlyTemplate(template: string) {\n  const content = template\n    .split(/({{\\w+}})/g)\n    .filter((part) => part !== \"\")\n    .map((part) =>\n      /^{{\\w+}}$/.test(part)\n        ? createMention(part.slice(2, -2))\n        : toTextNode(part)\n    );\n\n  return createDocument([createParagraph(content)]);\n}\n","export function capitalize<T extends string>(text: T) {\n  return `${text.slice(0, 1).toUpperCase()}${text.slice(1)}` as Capitalize<T>;\n}\n","export const ROLLOUTHQ_VARIABLE_PREFIX = \"ROLLOUTHQ_VARIABLE_\";\n\nexport function isVariable(id: string | undefined) {\n  return id != null && id.startsWith(ROLLOUTHQ_VARIABLE_PREFIX);\n}\n","import type { z, ZodType } from \"zod\";\n\nexport function zodGuard<T extends ZodType>(zodType: T) {\n  return (x: unknown): x is z.infer<T> => passesValidation(zodType, x);\n}\n\nexport function passesValidation<T extends ZodType>(\n  zodType: T,\n  x: unknown\n): x is z.infer<T> {\n  return zodType.safeParse(x).success;\n}\n","import {\n  boolean,\n  object,\n  record,\n  string,\n  ZodOptional,\n  ZodTypeAny,\n  union,\n  literal,\n} from \"zod\";\n\nimport { zRichEditorContent } from \"./zod-rich-editor-content\";\n\nexport * from \"./zod-rich-editor-content\";\n\nexport { inputDefToZodObject } from \"./input-def-to-zod-object\";\nexport type { InputDef } from \"./input-def-to-zod-object\";\n\nexport const z = {\n  literal,\n  boolean,\n  object,\n  record,\n  string,\n  richEditorContent: zRichEditorContent,\n  union,\n};\n\nexport function unwrapOptional(type: ZodTypeAny): ZodTypeAny {\n  if (type instanceof ZodOptional) {\n    return unwrapOptional(type.unwrap());\n  }\n  return type;\n}\n","import { z, ZodTypeAny } from \"zod\";\n\nimport { RichEditorContent, schema } from \"../rich-editor\";\n\nexport const zRichEditorContent = z\n  .object({})\n  .passthrough()\n  .refine(\n    (obj) => {\n      try {\n        schema.nodeFromJSON(obj);\n        return true;\n      } catch (err) {\n        return false;\n      }\n    },\n    {\n      message: \"Object is not valid RichEditorContent\",\n    }\n  )\n  .transform((obj) => obj as RichEditorContent);\n\nconst IS_Z_RICH_EDITOR_CONTENT = Symbol(\"IS_Z_RICH_EDITOR_CONTENT\");\nObject.assign(zRichEditorContent._def, { [IS_Z_RICH_EDITOR_CONTENT]: true });\n\nexport function isZRichEditorContent<T extends ZodTypeAny>(type: T) {\n  return IS_Z_RICH_EDITOR_CONTENT in type._def;\n}\n","import { unreachableCase } from \"ts-assert-unreachable\";\nimport { z } from \"zod\";\n\nimport { zRichEditorContent } from \"./zod-rich-editor-content\";\n\nexport type InputDef = {\n  key: string;\n  label: string;\n  type: \"string\" | \"plainText\" | \"dropdown\";\n};\n\nexport function inputDefToZodObject(inputs: InputDef[]) {\n  return z.object(\n    Object.fromEntries(\n      inputs.map((i) => {\n        if (i.type === \"plainText\") {\n          return [i.key, z.string()];\n        }\n        if (i.type === \"dropdown\") {\n          return [i.key, z.string()];\n        }\n        if (i.type === \"string\") {\n          return [i.key, zRichEditorContent];\n        }\n        unreachableCase(i.type);\n      })\n    )\n  );\n}\n"],"mappings":"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","names":["src_exports","__export","AnyBlockDocument","CURLY_BRACKETS_SYMBOL","CurlyBrackets","EnterHandler","EscHandler","FORMATTING_EXTENSIONS","Link","MENTION_SYMBOL","Mention","ROLLOUTHQ_VARIABLE_PREFIX","SCHEMA_EXTENSIONS","ShiftEnterHandler","SingleParagraphDocument","appendText","capitalize","createDocument","createDocumentWithMention","createMention","createParagraph","curlyBracketsConfig","curlyTemplate","flatMapMentions","getCurlyBracketsSuggestions","getSuggestions","getTextSeralizersFromSchema","inputDefToZodObject","isVariable","isZRichEditorContent","mentionConfig","passesValidation","plainToRichText","prependText","resolveMentions","richTextToPlain","schema","toHTML","toTextNode","unresolveMentions","unwrapOptional","z","zRichEditorContent","zodGuard","__toCommonJS","import_core","EnterHandler","props","import_core","EscHandler","props","import_extension_link","Link","TiptapLink","import_core","MENTION_SYMBOL","mentionConfig","chain","_a","newVariables","element","attributes","node","HTMLAttributes","variable","tr","state","isMention","selection","empty","anchor","pos","Mention","import_match_sorter","match","variables","query","option","getSuggestions","editor","mentionStorage","import_core","CURLY_BRACKETS_SYMBOL","curlyBracketsConfig","chain","_a","newVariables","element","attributes","node","HTMLAttributes","variable","tr","state","isCurlyBrackets","selection","empty","anchor","pos","CurlyBrackets","import_match_sorter","match","variables","query","option","getCurlyBracketsSuggestions","editor","curlyBracketsStorage","import_core","ShiftEnterHandler","props","import_extension_blockquote","import_extension_bold","import_extension_bullet_list","import_extension_code","import_extension_code_block","import_extension_gapcursor","import_extension_hard_break","import_extension_heading","import_extension_horizontal_rule","import_extension_italic","import_extension_list_item","import_extension_ordered_list","import_extension_strike","import_extension_underline","FORMATTING_EXTENSIONS","Blockquote","Bold","BulletList","Code","CodeBlock","Gapcursor","HardBreak","Heading","HorizontalRule","Italic","ListItem","OrderedList","Strike","Underline","import_core","AnyBlockDocument","import_core","SingleParagraphDocument","import_core","import_extension_paragraph","import_extension_text","SCHEMA_EXTENSIONS","AnyBlockDocument","Link","Mention","Paragraph","Text","CurlyBrackets","FORMATTING_EXTENSIONS","schema","OrderedMap","content","key","i","found","value","newKey","self","place","without","f","map","result","prop","orderedmap","index_es_default","findDiffStart","a","b","pos","i","let","childA","childB","j","inner","findDiffEnd","posA","posB","iA","iB","size","same","minSize","Fragment","content","from","to","f","nodeStart","parent","child","end","start","blockSeparator","leafText","text","separated","node","other","last","first","result","index","current","copy","prototypeAccessors","found","p","otherPos","round","retIndex","curPos","cur","n","schema","value","array","joined","nodes","const","offset","compareDeep","Mark","type","attrs","set","placed","obj","_","json","marks","ReplaceError","message","err","Slice","openStart","openEnd","fragment","insertInto","removeRange","openIsolating","ref","ref$1","indexTo","offsetTo","dist","insert","replace","$from","$to","slice","replaceOuter","depth","close","prepareSliceForReplace","replaceThreeWay","replaceTwoWay","checkJoin","main","sub","joinable","$before","$after","addNode","target","addRange","$start","$end","startIndex","endIndex","$along","extra","ResolvedPos","path","parentOffset","val","dOff","tmp","after","next","pred","d","NodeRange","str","doc","rem","resolveCache","cached","resolveCachePos","resolveCacheSize","prototypeAccessors$1","emptyAttrs","Node","startPos","includeParents","name","wrapMarks","match","replacement","one","two","m","TextNode","super","base","ContentMatch","validEnd","string","nodeTypes","stream","TokenStream","expr","parseExpr","dfa","nfa","checkForDeadEnds","frag","toEnd","seen","search","types","finished","tp","computed","active","scan","out","tok","exprs","parseExprSeq","parseExprSubscript","parseExprAtom","parseExprRange","parseNum","min","max","resolveName","typeName","connect","compile","edge","term","edges","loop","cmp","nullFrom","labeled","explore","states","known","state","work","dead","defaultAttrs","defaults","attrName","attr","computeAttrs","built","given","initAttrs","Attribute","NodeType","spec","before","markType","topType","options","MarkType","rank","Schema","prop","index_es_default","contentExprCache","contentExpr","markExpr","gatherMarks","excl","mark","ok","DOMParser","rules","rule","this","r","dom","context","ParseContext","matches","priority","nextPriority","loop$1","blockTags","ignoreTags","listTags","OPT_PRESERVE_WS","OPT_PRESERVE_WS_FULL","OPT_OPEN_LEFT","wsOptionsFor","preserveWhitespace","NodeContext","pendingMarks","solid","fill","wrap","nextType","pending","markMayApply","parser","open","topNode","topContext","topOptions","style","parseStyles","top","nodeBefore","domNodeBefore","matchAfter","ruleID","normalizeList","sync","oldNeedsBlock","styles","continueAfter","nodeType","startIn","contentDOM","route","cx","block","preserveWS","textNode","parts","option","useRoot","minDepth","part","$context","deflt","findSameMarkInSet","upto","level","stashMark","prevItem","selector","re","DOMSerializer","keep","rendered","add","markDOM","inline","toDOM","structure","xmlNS","tagName","space","innerContent","gatherToDOM","const","lower16","factor16","makeRecover","index","offset","recoverIndex","value","recoverOffset","MapResult","pos","deleted","recover","StepMap","ranges","inverted","let","diff","assoc","simple","oldIndex","newIndex","i","start","oldSize","newSize","end","side","result","f","oldStart","newStart","n","Mapping","maps","mirror","from","to","map","mirrors","mapping","startSize","mirr","m","totalSize","inverse","corr","TransformError","message","err","Transform","doc","prototypeAccessors","object","step","mustOverride","stepsByID","Step","_doc","_mapping","_other","schema","json","type","id","stepClass","StepResult","failed","slice","e","ReplaceError","ReplaceStep","structure","super","contentBetween","other","Slice","ReplaceAroundStep","gapFrom","gapTo","insert","gap","inserted","$from","dist","depth","next","Transform","range","target","$from","$to","depth","gapStart","gapEnd","start","end","before","Fragment","openStart","d","splitting","after","openEnd","ReplaceAroundStep","Slice","Transform","range","wrappers","content","Fragment","i","let","match","start","end","ReplaceAroundStep","Slice","from","to","type","attrs","mapFrom","node","pos","canChangeType","this","mapping","startM","endM","doc","$pos","index","marks","newNode","Transform","pos","depth","typesAfter","$pos","before","Fragment","after","d","e","i","let","typeAfter","ReplaceStep","Slice","Transform","pos","depth","let","step","ReplaceStep","Slice","insertPoint","doc","nodeType","$pos","d","index","mapFragment","fragment","f","parent","mapped","let","child","Fragment","AddMarkStep","Step","from","to","mark","super","doc","oldSlice","$from","slice","Slice","node","this","StepResult","RemoveMarkStep","mapping","other","schema","json","Transform","removed","added","removing","adding","pos","marks","start","end","newSet","i","s","matched","step","toRemove","MarkType","set","found","style","j","m","parentType","match","delSteps","cur","allowed","ReplaceStep","fill","replaceStep","$to","fitsTrivially","Fitter","content","prototypeAccessors","fit","moveInline","placedSize","openStart","openEnd","ReplaceAroundStep","pass","sliceDepth","contentAt","first","frontierDepth","ref","type","wrap","inject","inner","openAtEnd","dropFromFragment","taken","add","ref$1","openEndCount","next","matches","closeNodeStart","toEnd","addToFragment","top","level","contentAfterFits","depth","after","scan","dropInner","d","match$1","type$1","close","attrs","open","count","frag","index","invalidMarks","definesContent","targetDepths","coveredDepths","preferredTarget","spec","preferredTargetIndex","leftNodes","preferredDepth","def","openDepth","insert","targetDepth","expand","closeFragment","startSteps","oldOpen","newOpen","point","insertPoint","covered","last","result","minDepth","createDocument","content","createMention","variableId","createParagraph","createDocumentWithMention","plainToRichText","plainText","toTextNode","appendText","original","stringToAppend","plainToRichText","originalContent","schema","contentToAppend","paragraph","Transform","flatMapMentions","contentUnresolved","cb","c","prependText","original","stringToAppend","originalContent","schema","contentToAppend","paragraph","Transform","resolveMentions","contentResolved","variables","flatMapMentions","mention","variableId","variable","v","import_core","richTextToPlain","contentResolved","fallbackEmptyToLabel","blockSeparator","contentNode","schema","textSerializers","getTextSeralizersFromSchema","props","s","node","name","import_html","toHTML","resolvedContent","SCHEMA_EXTENSIONS","unresolveMentions","contentResolved","flatMapMentions","mention","curlyTemplate","template","content","part","createMention","toTextNode","createDocument","createParagraph","capitalize","text","ROLLOUTHQ_VARIABLE_PREFIX","isVariable","id","zodGuard","zodType","x","passesValidation","import_zod","import_zod","zRichEditorContent","obj","schema","IS_Z_RICH_EDITOR_CONTENT","isZRichEditorContent","type","import_ts_assert_unreachable","import_zod","inputDefToZodObject","inputs","i","zRichEditorContent","z","zRichEditorContent","unwrapOptional","type"]}